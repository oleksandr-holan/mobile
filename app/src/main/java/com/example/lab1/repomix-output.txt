This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-29T09:17:05.704Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
data/local/AppDatabase.kt
data/local/dao/MenuItemDao.kt
data/local/dao/OrderDao.kt
data/local/dao/OrderItemDao.kt
data/local/dao/UserDao.kt
data/local/MockMenuItemDataProvider.kt
data/model/MenuItem.kt
data/model/OrderEntity.kt
data/model/OrderItemEntity.kt
data/model/User.kt
data/preferences/AppSettingsKeys.kt
data/repository/AuthRepository.kt
data/repository/OrderRepository.kt
data/repository/OrderRepositoryImpl.kt
data/repository/ProfileRepository.kt
data/repository/SettingsRepository.kt
data/repository/SettingsRepositoryImpl.kt
di/DatabaseModule.kt
di/DataStoreModule.kt
di/RepositoryModule.kt
MainActivity.kt
ui/components/AppTopAppBar.kt
ui/components/BottomNavigationBar.kt
ui/components/MenuItemCard.kt
ui/feature/dailyspecials/DailySpecialsActivity.kt
ui/feature/home/MainAppScreen.kt
ui/feature/item/AddItemDetailsScreen.kt
ui/feature/item/AddItemDetailsViewModel.kt
ui/feature/login/LoginScreen.kt
ui/feature/login/LoginViewModel.kt
ui/feature/menu/MenuScreen.kt
ui/feature/menu/MenuViewModel.kt
ui/feature/order/OrderScreen.kt
ui/feature/order/OrderViewModel.kt
ui/feature/orderhistory/OrderHistoryActivity.kt
ui/feature/orderhistory/OrderHistoryAdapter.kt
ui/feature/orderhistory/OrderHistoryItem.kt
ui/feature/profile/ProfileScreen.kt
ui/feature/profile/ProfileViewModel.kt
ui/feature/register/RegistrationScreen.kt
ui/feature/register/RegistrationViewModel.kt
ui/feature/settings/SettingsScreen.kt
ui/feature/settings/SettingsViewModel.kt
ui/navigation/AppDestinations.kt
ui/navigation/BottomNavItem.kt
ui/theme/Color.kt
ui/theme/Theme.kt
ui/theme/Type.kt
util/DataResult.kt
util/ResourceUtils.kt
WaiterApplication.kt

================================================================
Files
================================================================

================
File: data/local/AppDatabase.kt
================
package com.example.lab1.data.local

import android.content.Context
import android.util.Log
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.sqlite.db.SupportSQLiteDatabase
import com.example.lab1.data.local.dao.MenuItemDao
import com.example.lab1.data.local.dao.OrderDao
import com.example.lab1.data.local.dao.OrderItemDao
import com.example.lab1.data.local.dao.UserDao
import com.example.lab1.data.model.MenuItem
import com.example.lab1.data.model.OrderEntity
import com.example.lab1.data.model.OrderItemEntity
import com.example.lab1.data.model.User
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@Database(
    entities = [MenuItem::class, OrderEntity::class, OrderItemEntity::class, User::class],
    version = 3,
    exportSchema = false
)
abstract class AppDatabase : RoomDatabase() {

    abstract fun menuItemDao(): MenuItemDao
    abstract fun orderDao(): OrderDao
    abstract fun orderItemDao(): OrderItemDao
    abstract fun userDao(): UserDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        private const val TAG = "AppDatabase"

        private class AppDatabaseCallback(
            private val applicationContext: Context,
            private val scope: CoroutineScope
        ) : Callback() {
            override fun onCreate(db: SupportSQLiteDatabase) {
                super.onCreate(db)
                Log.d(TAG, "Database onCreate called.")
                scope.launch(Dispatchers.IO) {
                    val databaseInstance = getDatabase(applicationContext, scope)
                    Log.d(TAG, "Coroutine in onCreate: Populating initial menu.")
                    populateInitialMenu(databaseInstance.menuItemDao())
                }
            }

            suspend fun populateInitialMenu(menuItemDao: MenuItemDao) {
                val currentCount = menuItemDao.getMenuItemsCount()
                Log.d(TAG, "populateInitialMenu called. Current menu items count: $currentCount")
                if (currentCount == 0) {
                    Log.d(TAG, "Populating initial menu items as count is 0.")
                    val initialMenuItems = MockMenuItemDataProvider.getMockMenuItems()
                    menuItemDao.insertAll(initialMenuItems)
                    Log.d(TAG, "Finished populating ${initialMenuItems.size} initial menu items. New count: ${menuItemDao.getMenuItemsCount()}")
                } else {
                    Log.d(TAG, "Menu items already exist (count: $currentCount). Skipping population.")
                }
            }
        }

        fun getDatabase(context: Context, coroutineScope: CoroutineScope): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: run {
                    Log.d(TAG, "Creating new database instance. Version: 3")
                    val instance = Room.databaseBuilder(
                        context.applicationContext,
                        AppDatabase::class.java,
                        "waiter_app_database"
                    )
                        .addCallback(AppDatabaseCallback(context.applicationContext, coroutineScope))
                        .fallbackToDestructiveMigration(true)
                        .build()
                    INSTANCE = instance
                    Log.d(TAG, "Database instance created and INSTANCE set.")
                    instance
                }
            }
        }
    }
}

================
File: data/local/dao/MenuItemDao.kt
================
package com.example.lab1.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.lab1.data.model.MenuItem
import kotlinx.coroutines.flow.Flow

@Dao
interface MenuItemDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(menuItems: List<MenuItem>)

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMenuItem(menuItem: MenuItem)

    @Query("SELECT * FROM menu_items ORDER BY category, nameKey")
    fun getAllMenuItems(): Flow<List<MenuItem>>

    @Query("SELECT * FROM menu_items WHERE id = :itemId")
    fun getMenuItemById(itemId: String): Flow<MenuItem?>

    @Query("SELECT COUNT(*) FROM menu_items")
    suspend fun getMenuItemsCount(): Int

    @Query("DELETE FROM menu_items WHERE id = :itemId")
    suspend fun deleteMenuItemById(itemId: String)

    @Query("DELETE FROM menu_items")
    suspend fun deleteAllMenuItems()
}

================
File: data/local/dao/OrderDao.kt
================
package com.example.lab1.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.lab1.data.model.OrderEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface OrderDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrder(order: OrderEntity): Long 

    @Update
    suspend fun updateOrder(order: OrderEntity)

    @Query("SELECT * FROM orders WHERE orderId = :orderId")
    fun getOrderById(orderId: Long): Flow<OrderEntity?>

    @Query("SELECT * FROM orders WHERE status = :status ORDER BY timestamp DESC")
    fun getOrdersByStatus(status: String): Flow<List<OrderEntity>>

    @Query("SELECT * FROM orders ORDER BY timestamp DESC")
    fun getAllOrders(): Flow<List<OrderEntity>>

    @Query("SELECT * FROM orders WHERE status = 'Active' ORDER BY timestamp DESC LIMIT 1")
    fun getLatestActiveOrder(): Flow<OrderEntity?>
}

================
File: data/local/dao/OrderItemDao.kt
================
package com.example.lab1.data.local.dao

import androidx.room.Dao
import androidx.room.Delete
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import androidx.room.Update
import com.example.lab1.data.model.OrderItemEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface OrderItemDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertOrderItem(orderItem: OrderItemEntity): Long

    @Update
    suspend fun updateOrderItem(orderItem: OrderItemEntity)

    @Delete
    suspend fun deleteOrderItem(orderItem: OrderItemEntity)

    @Query("SELECT * FROM order_items WHERE orderIdFk = :orderId ORDER BY orderItemId ASC")
    fun getOrderItemsForOrder(orderId: Long): Flow<List<OrderItemEntity>>

    @Query("SELECT * FROM order_items WHERE orderItemId = :orderItemId")
    fun getOrderItemById(orderItemId: Long): Flow<OrderItemEntity?>
}

================
File: data/local/dao/UserDao.kt
================
package com.example.lab1.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query
import com.example.lab1.data.model.User
import kotlinx.coroutines.flow.Flow

@Dao
interface UserDao {

    @Insert(onConflict = OnConflictStrategy.ABORT) // Prevent duplicate usernames
    suspend fun insertUser(user: User)

    @Query("SELECT * FROM users WHERE username = :username LIMIT 1")
    suspend fun getUserByUsername(username: String): User?

    @Query("SELECT * FROM users WHERE username = :username LIMIT 1")
    fun getUserByUsernameFlow(username: String): Flow<User?>
}

================
File: data/local/MockMenuItemDataProvider.kt
================
package com.example.lab1.data.local

import com.example.lab1.data.model.MenuItem

object MockMenuItemDataProvider {
    fun getMockMenuItems(): List<MenuItem> {
        return listOf(
            MenuItem("pizza1", "pizza1_name", "pizza1_desc", "150.00", "Pizza", imageUrl = null),
            MenuItem("pizza2", "pizza2_name", "pizza2_desc", "180.00", "Pizza", imageUrl = null),
            MenuItem("pizza3", "pizza3_name", "pizza3_desc", "170.00", "Pizza", imageUrl = null),
            MenuItem("salad1", "salad1_name", "salad1_desc", "120.00", "Salad", imageUrl = null),
            MenuItem("salad2", "salad2_name", "salad2_desc", "110.00", "Salad", imageUrl = null),
            MenuItem("drink1", "drink1_name", "drink1_desc", "30.00", "Drink", imageUrl = null),
            MenuItem("drink2", "drink2_name", "drink2_desc", "40.00", "Drink", imageUrl = null),
            MenuItem("dessert1", "dessert1_name", "dessert1_desc", "90.00", "Dessert", imageUrl = null)
        )
    }
}

================
File: data/model/MenuItem.kt
================
package com.example.lab1.data.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "menu_items")
data class MenuItem(
    @PrimaryKey
    val id: String,
    val nameKey: String,
    val descriptionKey: String,
    val price: String,
    val category: String,
    val imageUrl: String? = null
)

================
File: data/model/OrderEntity.kt
================
package com.example.lab1.data.model

import androidx.room.Entity
import androidx.room.PrimaryKey
import java.util.Calendar

@Entity(tableName = "orders")
data class OrderEntity(
    @PrimaryKey(autoGenerate = true)
    val orderId: Long = 0,
    val tableNumber: Int,
    val timestamp: Long = Calendar.getInstance().timeInMillis,
    val status: String = "Active"
)

================
File: data/model/OrderItemEntity.kt
================
package com.example.lab1.data.model

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "order_items",
    foreignKeys = [
        ForeignKey(
            entity = OrderEntity::class,
            parentColumns = ["orderId"],
            childColumns = ["orderIdFk"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index(value = ["orderIdFk"])]
)
data class OrderItemEntity(
    @PrimaryKey(autoGenerate = true)
    val orderItemId: Long = 0,
    val orderIdFk: Long,
    val menuOriginalId: String,
    val itemName: String,
    val itemPrice: String,
    var quantity: Int,
    var specialRequests: String? = null
)

================
File: data/model/User.kt
================
package com.example.lab1.data.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "users")
data class User(
    @PrimaryKey
    val username: String,
    val passwordHash: String,
    val dateOfBirth: String? = null 
)

================
File: data/preferences/AppSettingsKeys.kt
================
package com.example.lab1.data.preferences

import androidx.datastore.preferences.core.booleanPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey

object AppSettingsKeys {
    val NOTIFICATIONS_ENABLED = booleanPreferencesKey("notifications_enabled")
    val SOUNDS_ENABLED = booleanPreferencesKey("sounds_enabled")
    val APP_THEME = stringPreferencesKey("app_theme")
    val APP_LANGUAGE = stringPreferencesKey("app_language")
    val LOGGED_IN_USER_USERNAME = stringPreferencesKey("logged_in_user_username")
}

================
File: data/repository/AuthRepository.kt
================
package com.example.lab1.data.repository

import android.database.sqlite.SQLiteConstraintException
import android.util.Log
import com.example.lab1.data.local.dao.UserDao
import com.example.lab1.data.model.User
import kotlinx.coroutines.delay
import javax.inject.Inject
import javax.inject.Singleton

sealed class AuthResult {
    data object Success : AuthResult()
    data class Error(val message: String) : AuthResult()
}

interface AuthRepository {
    suspend fun login(username: String, passwordHash: String): AuthResult
    suspend fun register(username: String, passwordHash: String, dateOfBirth: String?): AuthResult
    suspend fun logout()
}

@Singleton
class AuthRepositoryImpl @Inject constructor(
    private val userDao: UserDao,
    private val settingsRepository: SettingsRepository
) : AuthRepository {
    private val tag = "AuthRepositoryImpl"

    override suspend fun login(username: String, passwordHash: String): AuthResult {
        delay(500) // Simulate network delay
        val user = userDao.getUserByUsername(username)
        return if (user != null && user.passwordHash == passwordHash) {
            Log.d(tag, "Login successful for user '$username'")
            settingsRepository.setLoggedInUserUsername(username)
            AuthResult.Success
        } else {
            Log.d(tag, "Login failed for user '$username'. User found: ${user != null}")
            AuthResult.Error("invalid_username_or_password_error")
        }
    }

    override suspend fun register(
        username: String,
        passwordHash: String,
        dateOfBirth: String?
    ): AuthResult {
        delay(1000) // Simulate network delay
        if (username.length < 4) {
            Log.d(tag, "Registration failed for user '$username'. Username too short.")
            return AuthResult.Error("username_too_short_error")
        }
        if (passwordHash.length < 6) {
            Log.d(tag, "Registration failed for user '$username'. Password too short.")
            return AuthResult.Error("password_too_short_error")
        }

        try {
            val newUser = User(username = username, passwordHash = passwordHash, dateOfBirth = dateOfBirth)
            userDao.insertUser(newUser)
            Log.d(tag, "Registration successful for user '$username'. DOB: $dateOfBirth")
            return AuthResult.Success
        } catch (e: SQLiteConstraintException) {
            Log.w(tag, "Registration failed for user '$username'. Username likely already exists.", e)
            return AuthResult.Error("username_already_exists_error")
        } catch (e: Exception) {
            Log.e(tag, "Registration failed for user '$username'. Exception: ${e.message}", e)
            return AuthResult.Error("registration_failed_unknown_error")
        }
    }

    override suspend fun logout() {
        Log.d(tag, "Logging out user")
        settingsRepository.setLoggedInUserUsername(null)
    }
}

================
File: data/repository/OrderRepository.kt
================
package com.example.lab1.data.repository

import com.example.lab1.data.model.MenuItem
import com.example.lab1.data.model.OrderEntity
import com.example.lab1.data.model.OrderItemEntity
import kotlinx.coroutines.flow.Flow

interface OrderRepository {
    fun getAllMenuItems(): Flow<List<MenuItem>>
    fun getMenuItemById(itemId: String): Flow<MenuItem?>
    suspend fun addMenuItem(menuItem: MenuItem) 
    suspend fun deleteMenuItem(itemId: String) 
    suspend fun getMenuItemCount(): Int 
    suspend fun clearAndRepopulateMenuItems()

    suspend fun createNewOrder(tableNumber: Int): Long 
    fun getOrderById(orderId: Long): Flow<OrderEntity?>
    fun getLatestActiveOrder(): Flow<OrderEntity?>
    suspend fun updateOrder(order: OrderEntity)

    suspend fun addOrderItemToOrder(orderItem: OrderItemEntity): Long
    suspend fun updateOrderItem(orderItem: OrderItemEntity)
    suspend fun deleteOrderItem(orderItem: OrderItemEntity)
    fun getOrderItemsForOrder(orderId: Long): Flow<List<OrderItemEntity>>
    fun getOrderItemById(orderItemId: Long): Flow<OrderItemEntity?>
}

================
File: data/repository/OrderRepositoryImpl.kt
================
package com.example.lab1.data.repository

import com.example.lab1.data.local.dao.MenuItemDao
import com.example.lab1.data.local.dao.OrderDao
import com.example.lab1.data.local.dao.OrderItemDao
import com.example.lab1.data.model.MenuItem
import com.example.lab1.data.model.OrderEntity
import com.example.lab1.data.model.OrderItemEntity
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class OrderRepositoryImpl @Inject constructor(
    private val menuItemDao: MenuItemDao,
    private val orderDao: OrderDao,
    private val orderItemDao: OrderItemDao
) : OrderRepository {

    override fun getAllMenuItems(): Flow<List<MenuItem>> {
        return menuItemDao.getAllMenuItems()
    }

    override fun getMenuItemById(itemId: String): Flow<MenuItem?> {
        return menuItemDao.getMenuItemById(itemId)
    }

    override suspend fun addMenuItem(menuItem: MenuItem) {
        menuItemDao.insertMenuItem(menuItem)
    }

    override suspend fun deleteMenuItem(itemId: String) {
        menuItemDao.deleteMenuItemById(itemId)
    }

    override suspend fun getMenuItemCount(): Int {
        return menuItemDao.getMenuItemsCount()
    }

    override suspend fun clearAndRepopulateMenuItems() {
        menuItemDao.deleteAllMenuItems()
    }

    override suspend fun createNewOrder(tableNumber: Int): Long {
        val newOrder = OrderEntity(tableNumber = tableNumber, status = "Active")
        return orderDao.insertOrder(newOrder)
    }

    override fun getOrderById(orderId: Long): Flow<OrderEntity?> {
        return orderDao.getOrderById(orderId)
    }

    override fun getLatestActiveOrder(): Flow<OrderEntity?> {
        return orderDao.getLatestActiveOrder()
    }

    override suspend fun updateOrder(order: OrderEntity) {
        orderDao.updateOrder(order)
    }

    override suspend fun addOrderItemToOrder(orderItem: OrderItemEntity): Long {
        return orderItemDao.insertOrderItem(orderItem)
    }

    override suspend fun updateOrderItem(orderItem: OrderItemEntity) {
        orderItemDao.updateOrderItem(orderItem)
    }

    override suspend fun deleteOrderItem(orderItem: OrderItemEntity) {
        orderItemDao.deleteOrderItem(orderItem)
    }

    override fun getOrderItemsForOrder(orderId: Long): Flow<List<OrderItemEntity>> {
        return orderItemDao.getOrderItemsForOrder(orderId)
    }

    override fun getOrderItemById(orderItemId: Long): Flow<OrderItemEntity?> {
        return orderItemDao.getOrderItemById(orderItemId)
    }
}

================
File: data/repository/ProfileRepository.kt
================
package com.example.lab1.data.repository

import com.example.lab1.util.DataResult
import kotlinx.coroutines.delay
import javax.inject.Inject
import javax.inject.Singleton

data class UserProfile(
    val userId: String,
    val username: String,
    val email: String,
    val dateOfBirth: String?,
    val memberSince: String,
    val profileImageUrl: String? = null 
)

interface ProfileRepository {
    suspend fun getUserProfile(userId: String): DataResult<UserProfile>
}

@Singleton
class MockProfileRepository @Inject constructor() : ProfileRepository {
    private val currentLoggedInUserId = "testuser"
    private val userProfiles = mapOf(
        "testuser" to UserProfile(
            userId = "testuser",
            username = "Test User",
            email = "test.user@example.com",
            dateOfBirth = "1990-01-01", 
            memberSince = "2023-01-15",
            profileImageUrl = "https://example.com/avatar/testuser.png" 
        ),
        "user" to UserProfile(
            userId = "user",
            username = "Another User",
            email = "user@example.com",
            dateOfBirth = "1985-05-20",
            memberSince = "2022-11-01"
        )
    )

    override suspend fun getUserProfile(userId: String): DataResult<UserProfile> {
        delay(500) 
        return userProfiles[userId]?.let {
            DataResult.Success(it)
        } ?: DataResult.Error("user_profile_not_found_error")
    }
    
    suspend fun getCurrentUserProfile(): DataResult<UserProfile> {
        return getUserProfile(currentLoggedInUserId)
    }
}

================
File: data/repository/SettingsRepository.kt
================
package com.example.lab1.data.repository

import kotlinx.coroutines.flow.Flow

interface SettingsRepository {
    val notificationsEnabledFlow: Flow<Boolean>
    suspend fun setNotificationsEnabled(enabled: Boolean)

    val soundsEnabledFlow: Flow<Boolean>
    suspend fun setSoundsEnabled(enabled: Boolean)

    val appThemeFlow: Flow<String>
    suspend fun setAppTheme(theme: String)

    val appLanguageFlow: Flow<String>
    suspend fun setAppLanguage(language: String)

    val loggedInUserUsernameFlow: Flow<String?>
    suspend fun setLoggedInUserUsername(username: String?)

    companion object {
        const val DEFAULT_THEME = "System"
        const val DEFAULT_LANGUAGE = "English"
    }
}

================
File: data/repository/SettingsRepositoryImpl.kt
================
package com.example.lab1.data.repository

import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.emptyPreferences
import com.example.lab1.data.preferences.AppSettingsKeys
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.map
import java.io.IOException
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SettingsRepositoryImpl @Inject constructor(
    private val dataStore: DataStore<Preferences>
) : SettingsRepository {

    override val notificationsEnabledFlow: Flow<Boolean> = dataStore.data
        .catch { exception ->
            if (exception is IOException) {
                emit(emptyPreferences())
            } else {
                throw exception
            }
        }
        .map { preferences ->
            preferences[AppSettingsKeys.NOTIFICATIONS_ENABLED] ?: true
        }

    override suspend fun setNotificationsEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[AppSettingsKeys.NOTIFICATIONS_ENABLED] = enabled
        }
    }

    override val soundsEnabledFlow: Flow<Boolean> = dataStore.data
        .catch { if (it is IOException) emit(emptyPreferences()) else throw it }
        .map { preferences ->
            preferences[AppSettingsKeys.SOUNDS_ENABLED] ?: true
        }

    override suspend fun setSoundsEnabled(enabled: Boolean) {
        dataStore.edit { preferences ->
            preferences[AppSettingsKeys.SOUNDS_ENABLED] = enabled
        }
    }

    override val appThemeFlow: Flow<String> = dataStore.data
        .catch { if (it is IOException) emit(emptyPreferences()) else throw it }
        .map { preferences ->
            preferences[AppSettingsKeys.APP_THEME] ?: SettingsRepository.DEFAULT_THEME
        }

    override suspend fun setAppTheme(theme: String) {
        dataStore.edit { preferences ->
            preferences[AppSettingsKeys.APP_THEME] = theme
        }
    }

    override val appLanguageFlow: Flow<String> = dataStore.data
        .catch { if (it is IOException) emit(emptyPreferences()) else throw it }
        .map { preferences ->
            preferences[AppSettingsKeys.APP_LANGUAGE] ?: SettingsRepository.DEFAULT_LANGUAGE
        }

    override suspend fun setAppLanguage(language: String) {
        dataStore.edit { preferences ->
            preferences[AppSettingsKeys.APP_LANGUAGE] = language
        }
    }

    override val loggedInUserUsernameFlow: Flow<String?> = dataStore.data
        .catch { if (it is IOException) emit(emptyPreferences()) else throw it }
        .map { preferences ->
            preferences[AppSettingsKeys.LOGGED_IN_USER_USERNAME]
        }

    override suspend fun setLoggedInUserUsername(username: String?) {
        dataStore.edit { preferences ->
            if (username != null) {
                preferences[AppSettingsKeys.LOGGED_IN_USER_USERNAME] = username
            } else {
                preferences.remove(AppSettingsKeys.LOGGED_IN_USER_USERNAME)
            }
        }
    }
}

================
File: di/DatabaseModule.kt
================
package com.example.lab1.di

import android.content.Context
import com.example.lab1.data.local.AppDatabase
import com.example.lab1.data.local.dao.MenuItemDao
import com.example.lab1.data.local.dao.OrderDao
import com.example.lab1.data.local.dao.OrderItemDao
import com.example.lab1.data.local.dao.UserDao
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {

    @Provides
    @Singleton
    fun provideApplicationScope(): CoroutineScope {
        return CoroutineScope(SupervisorJob() + Dispatchers.Default)
    }

    @Provides
    @Singleton
    fun provideAppDatabase(
        @ApplicationContext context: Context,
        applicationScope: CoroutineScope
    ): AppDatabase {
        return AppDatabase.getDatabase(context, applicationScope)
    }

    @Provides
    @Singleton
    fun provideMenuItemDao(appDatabase: AppDatabase): MenuItemDao {
        return appDatabase.menuItemDao()
    }

    @Provides
    @Singleton
    fun provideOrderDao(appDatabase: AppDatabase): OrderDao {
        return appDatabase.orderDao()
    }

    @Provides
    @Singleton
    fun provideOrderItemDao(appDatabase: AppDatabase): OrderItemDao {
        return appDatabase.orderItemDao()
    }

    @Provides
    @Singleton
    fun provideUserDao(appDatabase: AppDatabase): UserDao {
        return appDatabase.userDao()
    }
}

================
File: di/DataStoreModule.kt
================
package com.example.lab1.di

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.preferencesDataStore
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

private val Context.appSettingsDataStore: DataStore<Preferences> by preferencesDataStore(name = "app_settings")

@Module
@InstallIn(SingletonComponent::class)
object DataStoreModule {

    @Provides
    @Singleton
    fun provideAppSettingsDataStore(@ApplicationContext context: Context): DataStore<Preferences> {
        return context.appSettingsDataStore
    }
}

================
File: di/RepositoryModule.kt
================
package com.example.lab1.di

import com.example.lab1.data.repository.AuthRepository
import com.example.lab1.data.repository.AuthRepositoryImpl
import com.example.lab1.data.repository.OrderRepository
import com.example.lab1.data.repository.OrderRepositoryImpl
import com.example.lab1.data.repository.SettingsRepository
import com.example.lab1.data.repository.SettingsRepositoryImpl
import com.example.lab1.data.repository.ProfileRepository
import com.example.lab1.data.repository.MockProfileRepository
import dagger.Binds
import dagger.Module
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {

    @Binds
    @Singleton
    abstract fun bindSettingsRepository(
        settingsRepositoryImpl: SettingsRepositoryImpl
    ): SettingsRepository

    @Binds
    @Singleton
    abstract fun bindOrderRepository(
        orderRepositoryImpl: OrderRepositoryImpl
    ): OrderRepository

    @Binds
    @Singleton
    abstract fun bindAuthRepository(
        authRepositoryImpl: AuthRepositoryImpl
    ): AuthRepository

    @Binds
    @Singleton
    abstract fun bindProfileRepository(
        mockProfileRepository: MockProfileRepository
    ): ProfileRepository
}

================
File: MainActivity.kt
================
package com.example.lab1

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.core.view.WindowCompat
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.example.lab1.data.repository.SettingsRepository
import com.example.lab1.ui.feature.home.MainAppScreen
import com.example.lab1.ui.feature.login.LoginScreen
import com.example.lab1.ui.feature.register.RegistrationScreen
import com.example.lab1.ui.navigation.AppDestinations
import com.example.lab1.ui.theme.Lab1Theme
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject
import java.util.Locale
import kotlinx.coroutines.flow.first

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    private val tag = "MainActivityLifecycle"

    @Inject 
    lateinit var settingsRepository: SettingsRepository

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(tag, "onCreate called")
        WindowCompat.setDecorFitsSystemWindows(window, false)

        setContent {
            val currentThemeSetting by settingsRepository.appThemeFlow
                .collectAsState(initial = SettingsRepository.DEFAULT_THEME)
            val persistedLanguageSetting by settingsRepository.appLanguageFlow
                .collectAsState(initial = null)

            var languageToApplyForUI by remember { mutableStateOf<String?>(null) }
            var startDestination by remember { mutableStateOf<String?>(null) }

            val navController: NavHostController = rememberNavController()

            LaunchedEffect(key1 = Unit) {
                val loggedInUser = settingsRepository.loggedInUserUsernameFlow.first()
                startDestination = if (loggedInUser != null && loggedInUser.isNotBlank()) {
                    Log.d(tag, "User '$loggedInUser' is logged in. Navigating to Main App.")
                    AppDestinations.MAIN_APP_ROUTE
                } else {
                    Log.d(tag, "No user logged in. Navigating to Login.")
                    AppDestinations.LOGIN_ROUTE
                }
            }

            LaunchedEffect(persistedLanguageSetting) {
                if (persistedLanguageSetting == null) {
                    Log.d(tag, "[[LAUNCHED_EFFECT_LANG]] Waiting for DataStore to emit a language setting...")
                    return@LaunchedEffect
                }

                val targetLanguage = if (persistedLanguageSetting!!.isNotEmpty()) {
                    persistedLanguageSetting
                } else {
                    SettingsRepository.DEFAULT_LANGUAGE
                }
                Log.d(tag, "[[LAUNCHED_EFFECT_LANG]] Target language determined: $targetLanguage (from persisted: '$persistedLanguageSetting')")

                val locale = Locale(targetLanguage!!)
                val config = resources.configuration
                val currentActivityLocale = Locale(config.locales[0].toLanguageTag())

                if (currentActivityLocale != locale || Locale.getDefault() != locale) {
                    Locale.setDefault(locale)
                    config.setLocale(locale)
                    @Suppress("DEPRECATION")
                    resources.updateConfiguration(config, resources.displayMetrics)
                    Log.d(tag, "[[LAUNCHED_EFFECT_LANG]] Locale updated. Default: ${Locale.getDefault()}, Resources: $locale. From old: $currentActivityLocale")
                } else {
                    Log.d(tag, "[[LAUNCHED_EFFECT_LANG]] Locale $locale already effectively set.")
                }
                languageToApplyForUI = targetLanguage
            }

            if (languageToApplyForUI == null || startDestination == null) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Log.d(tag, "Waiting for language ($languageToApplyForUI) or start destination ($startDestination), showing loading indicator.")
                    CircularProgressIndicator()
                }
            } else {
                key(languageToApplyForUI) { 
                    Log.d(tag, "[[KEY_BLOCK_LANG]] Recomposing with language: $languageToApplyForUI. Current Locale.getDefault(): ${Locale.getDefault().language}")
                    val useDarkTheme = when (currentThemeSetting) {
                        "Dark" -> true
                        "Light" -> false
                        else -> isSystemInDarkTheme()
                    }
                    Lab1Theme(darkTheme = useDarkTheme) {
                        Surface(
                            modifier = Modifier.fillMaxSize(),
                            color = MaterialTheme.colorScheme.background
                        ) {
                            Log.d(tag, "[[SURFACE_IN_KEY_BLOCK]] AppNavigationHost to be composed. Start: $startDestination, Language: $languageToApplyForUI. Locale.getDefault(): ${Locale.getDefault().language}")
                            AppNavigationHost(navController = navController, startDestination = startDestination!!)
                        }
                    }
                }
            }
        }
    }

    override fun onStart() {
        super.onStart()
        Log.d(tag, "onStart called")
    }

    override fun onResume() {
        super.onResume()
        Log.d(tag, "onResume called")
        // It's a good practice to re-check language settings onResume 
        // if you expect changes from other parts of the app or system settings
        // For this basic implementation, we rely on app restart for full effect.
    }

    override fun onPause() {
        super.onPause()
        Log.d(tag, "onPause called")
    }

    override fun onStop() {
        super.onStop()
        Log.d(tag, "onStop called")
    }

    override fun onRestart() {
        super.onRestart()
        Log.d(tag, "onRestart called") 
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(tag, "onDestroy called")
    }
}

@Composable
fun AppNavigationHost(navController: NavHostController, startDestination: String) {
    Log.d("AppNavigationHost", "Composing with startDestination: $startDestination. Current Locale.getDefault(): ${Locale.getDefault().language}. LoginScreen title res ID: ${R.string.login_title}")
    NavHost(
        navController = navController,
        startDestination = startDestination
    ) {
        composable(route = AppDestinations.LOGIN_ROUTE) {
            LoginScreen(
                onLoginSuccess = {
                    navController.navigate(AppDestinations.MAIN_APP_ROUTE) {
                        popUpTo(AppDestinations.LOGIN_ROUTE) {
                            inclusive = true
                        }
                        launchSingleTop = true
                    }
                },
                onNavigateToRegister = {
                    navController.navigate(AppDestinations.REGISTRATION_ROUTE)
                }
            )
        }

        composable(route = AppDestinations.REGISTRATION_ROUTE) {
            RegistrationScreen(
                onRegistrationSuccess = {
                    navController.navigate(AppDestinations.MAIN_APP_ROUTE) {
                        popUpTo(AppDestinations.LOGIN_ROUTE) {
                            inclusive = true
                        }
                        launchSingleTop = true
                    }
                },
                onNavigateBackToLogin = {
                    navController.popBackStack()
                }
            )
        }

        composable(route = AppDestinations.MAIN_APP_ROUTE) {
            MainAppScreen(outerNavController = navController)
        }
    }
}

================
File: ui/components/AppTopAppBar.kt
================
package com.example.lab1.ui.components

import androidx.compose.foundation.layout.RowScope
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.res.stringResource
import com.example.lab1.R

@OptIn(ExperimentalMaterial3Api::class) 
@Composable
fun AppTopAppBar(
    title: String,
    canNavigateBack: Boolean,
    onNavigateBack: () -> Unit,
    actions: @Composable RowScope.() -> Unit = {}
) {
    TopAppBar(
        title = { Text(title) },
        navigationIcon = {
            if (canNavigateBack) {
                IconButton(onClick = onNavigateBack) {
                    Icon(
                        imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                        contentDescription = stringResource(R.string.back_button_desc) 
                    )
                }
            }
        },
        actions = actions
    )
}

================
File: ui/components/BottomNavigationBar.kt
================
package com.example.lab1.ui.components

import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.res.stringResource
import androidx.navigation.NavController
import androidx.navigation.compose.currentBackStackEntryAsState
import com.example.lab1.ui.navigation.bottomNavItems 

@Composable
fun AppBottomNavigationBar(navController: NavController) {
    NavigationBar { 
        val navBackStackEntry by navController.currentBackStackEntryAsState()
        val currentRoute = navBackStackEntry?.destination?.route

        bottomNavItems.forEach { item ->
            NavigationBarItem(
                selected = currentRoute == item.route,
                onClick = {
                    if (currentRoute != item.route) {
                        navController.navigate(item.route) {
                            val startDestination = navController.graph.startDestinationRoute
                            if (startDestination != null) {
                                popUpTo(startDestination) {
                                    saveState = true 
                                }
                            }
                            launchSingleTop = true
                            restoreState = true
                        }
                    }
                },
                icon = { Icon(item.icon, contentDescription = stringResource(item.titleResId)) },
                label = { Text(stringResource(item.titleResId)) },
                alwaysShowLabel = true 
            )
        }
    }
}

================
File: ui/components/MenuItemCard.kt
================
package com.example.lab1.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.RestaurantMenu
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.lab1.util.getStringResourceForKey

@Composable
fun MenuItemCard(
    itemNameKey: String,
    itemDescriptionKey: String,
    price: String
) {
    val context = LocalContext.current
    val itemName = getStringResourceForKey(context, itemNameKey)
    val itemDescription = getStringResourceForKey(context, itemDescriptionKey)

    Row(
        modifier = Modifier
            .fillMaxWidth()
            .shadow(4.dp, RoundedCornerShape(12.dp))
            .background(MaterialTheme.colorScheme.surfaceVariant, RoundedCornerShape(12.dp))
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = Icons.Filled.RestaurantMenu,
            contentDescription = itemName,
            tint = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .size(60.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.5f))
                .padding(8.dp)
        )
        Spacer(modifier = Modifier.width(16.dp))
        Column(modifier = Modifier.weight(1f)) {
            Text(
                itemName,
                fontSize = 18.sp,
                fontWeight = FontWeight.SemiBold,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                itemDescription,
                fontSize = 14.sp,
                color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),
                modifier = Modifier.padding(top = 4.dp)
            )
            Text(
                price,
                fontSize = 16.sp,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary,
                modifier = Modifier.padding(top = 8.dp)
            )
        }
    }
}

================
File: ui/feature/dailyspecials/DailySpecialsActivity.kt
================
package com.example.lab1.ui.feature.dailyspecials

import android.os.Bundle
import android.view.View
import android.widget.Button
import androidx.activity.ComponentActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import com.example.lab1.R

class DailySpecialsActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        WindowCompat.setDecorFitsSystemWindows(window, false)
        setContentView(R.layout.activity_daily_specials)

        val rootView = findViewById<View>(R.id.daily_specials_root_layout)
        val buttonClose = findViewById<Button>(R.id.buttonClose)

        buttonClose.setOnClickListener {
            finish() // Close the activity
        }

        // Store original padding values from XML
        val originalPaddingLeft = rootView.paddingLeft
        val originalPaddingTop = rootView.paddingTop
        val originalPaddingRight = rootView.paddingRight
        val originalPaddingBottom = rootView.paddingBottom

        ViewCompat.setOnApplyWindowInsetsListener(rootView) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            // Apply original XML padding + system bar insets
            v.setPadding(
                originalPaddingLeft + systemBars.left,
                originalPaddingTop + systemBars.top,
                originalPaddingRight + systemBars.right,
                originalPaddingBottom + systemBars.bottom
            )
            insets
        }
    }
}

================
File: ui/feature/home/MainAppScreen.kt
================
package com.example.lab1.ui.feature.home

import android.content.Intent
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.outlined.History
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.currentBackStackEntryAsState
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.example.lab1.ui.navigation.AppDestinations
import com.example.lab1.ui.navigation.BottomNavItem
import com.example.lab1.ui.navigation.bottomNavItems
import androidx.compose.ui.res.stringResource
import com.example.lab1.R

import com.example.lab1.ui.components.AppBottomNavigationBar
import com.example.lab1.ui.components.AppTopAppBar
import com.example.lab1.ui.feature.menu.MenuScreen
import com.example.lab1.ui.feature.order.OrderScreen
import com.example.lab1.ui.feature.orderhistory.OrderHistoryActivity
import com.example.lab1.ui.feature.profile.ProfileScreen
import com.example.lab1.ui.feature.settings.SettingsScreen
import com.example.lab1.ui.feature.item.AddItemDetailsScreen

@Composable
fun MainAppScreen(outerNavController: NavHostController) {
    val innerNavController: NavHostController = rememberNavController()
    val navBackStackEntry by innerNavController.currentBackStackEntryAsState()
    val currentRoute = navBackStackEntry?.destination?.route
    val context = LocalContext.current

    val currentScreenTitle = currentRoute?.let {
        when {
            it == BottomNavItem.Orders.route -> stringResource(BottomNavItem.Orders.titleResId)
            it == BottomNavItem.Profile.route -> stringResource(BottomNavItem.Profile.titleResId)
            it == AppDestinations.MENU_SCREEN_ROUTE -> stringResource(R.string.select_menu_items_title)
            it.startsWith(AppDestinations.ADD_ITEM_DETAILS_ROUTE) -> stringResource(R.string.item_details_title)
            it == BottomNavItem.Settings.route -> stringResource(BottomNavItem.Settings.titleResId)
            else -> stringResource(R.string.order_app_title)
        }
    } ?: stringResource(R.string.order_app_title)

    val canNavigateBack = remember(currentRoute) {
        bottomNavItems.none { it.route == currentRoute } &&
                currentRoute != null &&
                currentRoute != BottomNavItem.Orders.route
    }

    Scaffold(
        topBar = {
            AppTopAppBar(
                title = currentScreenTitle,
                canNavigateBack = canNavigateBack, 
                onNavigateBack = { innerNavController.popBackStack() },
                actions = {
                    if (currentRoute == BottomNavItem.Orders.route) {
                        IconButton(onClick = { 
                            context.startActivity(Intent(context, OrderHistoryActivity::class.java))
                        }) {
                            Icon(
                                imageVector = Icons.Outlined.History,
                                contentDescription = stringResource(R.string.order_history_title)
                            )
                        }
                    }
                }
            )
        },
        bottomBar = {
            val currentBottomNavRoute = navBackStackEntry?.destination?.route
            if (bottomNavItems.any { it.route == currentBottomNavRoute}) {
                AppBottomNavigationBar(navController = innerNavController)
            }
        }
    ) { innerPadding ->
        NavHost(
            navController = innerNavController,
            startDestination = BottomNavItem.Orders.route,
            modifier = Modifier.padding(innerPadding)
        ) {
            composable(BottomNavItem.Orders.route) {
                OrderScreen(
                    innerNavController = innerNavController
                )
            }
            composable(BottomNavItem.Profile.route) {
                ProfileScreen(
                    onNavigateToLogin = {
                        outerNavController.navigate(AppDestinations.LOGIN_ROUTE) {
                            popUpTo(AppDestinations.MAIN_APP_ROUTE) { inclusive = true }
                            launchSingleTop = true
                        }
                    }
                )
            }

            composable(
                route = AppDestinations.MENU_SCREEN_WITH_ORDER_ROUTE,
                arguments = listOf(
                    navArgument(AppDestinations.ARG_ACTIVE_ORDER_ID) { type = NavType.LongType }
                )
            ) { backStackEntry ->
                val activeOrderId = backStackEntry.arguments?.getLong(AppDestinations.ARG_ACTIVE_ORDER_ID)
                if (activeOrderId != null && activeOrderId != 0L) {
                    MenuScreen(
                        onNavigateToNewOrderItemDetails = { menuItemId ->
                            innerNavController.navigate(
                                AppDestinations.NEW_ORDER_ITEM_DETAILS_ROUTE
                                    .replace("{${AppDestinations.ARG_MENU_ITEM_ID}}", menuItemId)
                                    .replace("{${AppDestinations.ARG_ACTIVE_ORDER_ID}}", activeOrderId.toString())
                            )
                        }
                    )
                } else {
                    Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                        Text(stringResource(R.string.error_active_order_id_missing))
                    }
                }
            }

            composable(
                route = AppDestinations.NEW_ORDER_ITEM_DETAILS_ROUTE,
                arguments = listOf(
                    navArgument(AppDestinations.ARG_MENU_ITEM_ID) { type = NavType.StringType },
                    navArgument(AppDestinations.ARG_ACTIVE_ORDER_ID) { type = NavType.LongType }
                )
            ) {
                AddItemDetailsScreen(
                    onNavigateBack = { innerNavController.popBackStack() }
                )
            }

            composable(
                route = AppDestinations.EDIT_ORDER_ITEM_DETAILS_ROUTE,
                arguments = listOf(
                    navArgument(AppDestinations.ARG_ITEM_ID) { type = NavType.LongType }
                )
            ) {
                AddItemDetailsScreen(
                    onNavigateBack = { innerNavController.popBackStack() }
                )
            }

            composable(BottomNavItem.Settings.route) {
                SettingsScreen()
            }
        }
    }
}

================
File: ui/feature/item/AddItemDetailsScreen.kt
================
package com.example.lab1.ui.feature.item

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.flowWithLifecycle
import kotlinx.coroutines.flow.collectLatest
import androidx.compose.ui.res.stringResource
import com.example.lab1.R


@Composable
fun AddItemDetailsScreen(
    onNavigateBack: () -> Unit,
    addItemDetailsViewModel: AddItemDetailsViewModel = hiltViewModel()
) {
    val uiState by addItemDetailsViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(addItemDetailsViewModel.sideEffect, lifecycleOwner) {
        addItemDetailsViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collectLatest { effect ->
            when (effect) {
                AddItemDetailsSideEffect.NavigateBack -> {
                    onNavigateBack()
                }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .safeDrawingPadding()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        if (uiState.isLoading) {
            Spacer(modifier = Modifier.height(24.dp))
            CircularProgressIndicator()
            Spacer(modifier = Modifier.height(16.dp))
            Text(stringResource(R.string.add_item_details_loading))
        } else if (uiState.errorMessage != null) {
            Text(
                text = when (uiState.errorMessage) {
                    "invalid_item_or_order_error" -> stringResource(R.string.invalid_item_or_order_error)
                    "menu_item_not_found_error" -> stringResource(R.string.menu_item_not_found_error)
                    "order_item_details_not_found_error" -> stringResource(R.string.order_item_details_not_found_error)
                    "missing_item_base_info_error" -> stringResource(R.string.missing_item_base_info_error)
                    "failed_to_find_item_to_update_error" -> stringResource(R.string.failed_to_find_item_to_update_error)
                    "order_info_missing_error" -> stringResource(R.string.order_info_missing_error)
                    "error_saving_item_error" -> stringResource(R.string.error_saving_item_error)
                    else -> stringResource(R.string.generic_error_text, uiState.errorMessage!!)
                },
                color = MaterialTheme.colorScheme.error,
                modifier = Modifier.padding(vertical = 16.dp)
            )
        }

        if (!uiState.isLoading) {
            Text(
                text = if (uiState.isEditMode) stringResource(R.string.add_item_details_edit_title) else stringResource(R.string.add_item_details_add_title),
                style = MaterialTheme.typography.headlineSmall
            )
            Text(
                text = uiState.itemName,
                style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.Bold),
                modifier = Modifier.padding(bottom = 8.dp)
            )
            Text(
                text = stringResource(R.string.price_label, uiState.itemPrice),
                style = MaterialTheme.typography.bodyLarge,
                modifier = Modifier.padding(bottom = 16.dp)
            )

            Text(stringResource(R.string.quantity_label, uiState.roundedQuantity), style = MaterialTheme.typography.bodyLarge)
            Slider(
                value = uiState.quantity,
                onValueChange = {
                    addItemDetailsViewModel.onAction(
                        AddItemDetailsAction.QuantityChanged(it)
                    )
                },
                valueRange = 1f..10f,
                steps = 8,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 8.dp),
                enabled = !uiState.isSaving && uiState.errorMessage == null
            )
            Spacer(modifier = Modifier.height(16.dp))
            OutlinedTextField(
                value = uiState.specialRequests,
                onValueChange = {
                    addItemDetailsViewModel.onAction(
                        AddItemDetailsAction.SpecialRequestsChanged(it)
                    )
                },
                label = { Text(stringResource(R.string.special_requests_label)) },
                modifier = Modifier.fillMaxWidth(),
                maxLines = 3,
                enabled = !uiState.isSaving && uiState.errorMessage == null
            )
            Spacer(modifier = Modifier.height(16.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(stringResource(R.string.mark_as_urgent_label), style = MaterialTheme.typography.bodyLarge)
                Switch(
                    checked = uiState.isUrgent,
                    onCheckedChange = {
                        addItemDetailsViewModel.onAction(
                            AddItemDetailsAction.UrgencyChanged(it)
                        )
                    },
                    enabled = !uiState.isSaving && uiState.errorMessage == null
                )
            }
        }
        Spacer(modifier = Modifier.weight(1f))
        Button(
            onClick = { addItemDetailsViewModel.onAction(AddItemDetailsAction.SaveOrUpdateItemClicked) },
            modifier = Modifier
                .fillMaxWidth()
                .height(50.dp),
            enabled = !uiState.isSaving && uiState.errorMessage == null && uiState.menuItemOriginalId != null
        ) {
            if (uiState.isSaving) {
                CircularProgressIndicator(
                    modifier = Modifier.size(24.dp),
                    color = MaterialTheme.colorScheme.onPrimary
                )
            } else {
                Text(
                    text = when (uiState.buttonText) {
                        "add_to_order_button" -> stringResource(R.string.add_to_order_button)
                        "update_item_button" -> stringResource(R.string.update_item_button)
                        else -> uiState.buttonText // Should not happen
                    },
                    fontSize = 16.sp
                )
            }
        }
    }
}

================
File: ui/feature/item/AddItemDetailsViewModel.kt
================
package com.example.lab1.ui.feature.item

import android.util.Log
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.model.OrderItemEntity
import com.example.lab1.data.repository.OrderRepository
import com.example.lab1.ui.navigation.AppDestinations
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject
import kotlin.math.roundToInt
import android.content.Context
import com.example.lab1.util.getStringResourceForKey
import dagger.hilt.android.qualifiers.ApplicationContext

data class AddItemDetailsScreenState(
    val currentOrderItemId: Long? = null,
    val activeOrderIdForNewItem: Long? = null,
    val menuItemOriginalId: String? = null,
    val itemName: String = "Loading...",
    var itemPrice: String = "0.00",
    val quantity: Float = 1f,
    val specialRequests: String = "",
    val isUrgent: Boolean = false,
    val isLoading: Boolean = true,
    val isSaving: Boolean = false,
    val errorMessage: String? = null,
    val buttonText: String = "add_to_order_button"
) {
    val roundedQuantity: Int get() = quantity.roundToInt()
    val isEditMode: Boolean get() = currentOrderItemId != null
}

sealed class AddItemDetailsAction {
    data class QuantityChanged(val newQuantity: Float) : AddItemDetailsAction()
    data class SpecialRequestsChanged(val requests: String) : AddItemDetailsAction()
    data class UrgencyChanged(val urgent: Boolean) : AddItemDetailsAction()
    data object SaveOrUpdateItemClicked : AddItemDetailsAction()
}

sealed class AddItemDetailsSideEffect {
    data object NavigateBack : AddItemDetailsSideEffect()
}

@HiltViewModel
class AddItemDetailsViewModel @Inject constructor(
    private val orderRepository: OrderRepository,
    savedStateHandle: SavedStateHandle,
    @ApplicationContext private val applicationContext: Context
) : ViewModel() {

    private val _uiState = MutableStateFlow(AddItemDetailsScreenState())
    val uiState: StateFlow<AddItemDetailsScreenState> = _uiState.asStateFlow()

    private val _sideEffect = MutableSharedFlow<AddItemDetailsSideEffect>()
    val sideEffect: SharedFlow<AddItemDetailsSideEffect> = _sideEffect.asSharedFlow()

    init {
        val editingOrderItemId: Long? = savedStateHandle[AppDestinations.ARG_ITEM_ID]
        val newFromMenuItemId: String? = savedStateHandle[AppDestinations.ARG_MENU_ITEM_ID]
        val activeOrderIdForNew: Long? = savedStateHandle[AppDestinations.ARG_ACTIVE_ORDER_ID]

        _uiState.update { it.copy(buttonText = if (editingOrderItemId != null) "update_item_button" else "add_to_order_button") }

        if (editingOrderItemId != null && editingOrderItemId != 0L) {
            _uiState.update { it.copy(currentOrderItemId = editingOrderItemId) }
            fetchOrderItemDetailsForEdit(editingOrderItemId)
        } else if (newFromMenuItemId != null && activeOrderIdForNew != null && activeOrderIdForNew != 0L) {
            _uiState.update { it.copy(activeOrderIdForNewItem = activeOrderIdForNew) }
            fetchMenuItemDetailsForNewOrder(newFromMenuItemId)
        } else {
            _uiState.update {
                it.copy(
                    isLoading = false,
                    errorMessage = "invalid_item_or_order_error",
                    itemName = "Error"
                )
            }
        }
    }

    private fun fetchMenuItemDetailsForNewOrder(menuItemId: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            orderRepository.getMenuItemById(menuItemId).collectLatest { menuItem ->
                if (menuItem != null) {
                    Log.d("AddItemDetailsVM", "Context locale in fetchMenuItemDetailsForNewOrder: ${applicationContext.resources.configuration.locales[0].toLanguageTag()}")
                    _uiState.update {
                        it.copy(
                            menuItemOriginalId = menuItem.id,
                            itemName = getStringResourceForKey(applicationContext, menuItem.nameKey),
                            itemPrice = menuItem.price,
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            errorMessage = "menu_item_not_found_error",
                            itemName = "Unknown Item"
                        )
                    }
                }
            }
        }
    }

    private fun fetchOrderItemDetailsForEdit(orderItemId: Long) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            orderRepository.getOrderItemById(orderItemId).collectLatest { orderItemEntity ->
                if (orderItemEntity != null) {
                    _uiState.update {
                        it.copy(
                            menuItemOriginalId = orderItemEntity.menuOriginalId,
                            itemName = orderItemEntity.itemName,
                            itemPrice = orderItemEntity.itemPrice,
                            quantity = orderItemEntity.quantity.toFloat(),
                            specialRequests = orderItemEntity.specialRequests ?: "",
                            isLoading = false
                        )
                    }
                } else {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            errorMessage = "order_item_details_not_found_error",
                            itemName = "Unknown Item"
                        )
                    }
                }
            }
        }
    }

    fun onAction(action: AddItemDetailsAction) {
        _uiState.update { it.copy(errorMessage = null) }

        when (action) {
            is AddItemDetailsAction.QuantityChanged -> _uiState.update { it.copy(quantity = action.newQuantity) }
            is AddItemDetailsAction.SpecialRequestsChanged -> _uiState.update {
                it.copy(
                    specialRequests = action.requests
                )
            }

            is AddItemDetailsAction.UrgencyChanged -> _uiState.update { it.copy(isUrgent = action.urgent) }
            AddItemDetailsAction.SaveOrUpdateItemClicked -> handleSaveOrUpdate()
        }
    }

    private fun handleSaveOrUpdate() {
        val currentState = _uiState.value
        if (currentState.isLoading || currentState.isSaving) return
        if (currentState.menuItemOriginalId == null) {
            _uiState.update { it.copy(errorMessage = "missing_item_base_info_error") }
            return
        }

        _uiState.update { it.copy(isSaving = true) }

        viewModelScope.launch {
            try {
                if (currentState.isEditMode && currentState.currentOrderItemId != null) {
                    val existingItem =
                        orderRepository.getOrderItemById(currentState.currentOrderItemId).first()
                    if (existingItem != null) {
                        val itemToUpdate = existingItem.copy(
                            quantity = currentState.roundedQuantity,
                            specialRequests = currentState.specialRequests.takeIf { it.isNotBlank() }

                        )
                        orderRepository.updateOrderItem(itemToUpdate)
                        _sideEffect.emit(AddItemDetailsSideEffect.NavigateBack)
                    } else {
                        _uiState.update { it.copy(errorMessage = "failed_to_find_item_to_update_error") }
                    }

                } else if (currentState.activeOrderIdForNewItem != null) {
                    val baseMenuItem = orderRepository.getMenuItemById(currentState.menuItemOriginalId).first()
                    if (baseMenuItem == null) {
                        _uiState.update { it.copy(errorMessage = "menu_item_not_found_error") }
                        return@launch
                    }
                    val newOrderItem = OrderItemEntity(
                        orderIdFk = currentState.activeOrderIdForNewItem,
                        menuOriginalId = currentState.menuItemOriginalId,
                        itemName = getStringResourceForKey(applicationContext, baseMenuItem.nameKey),
                        itemPrice = baseMenuItem.price,
                        quantity = currentState.roundedQuantity,
                        specialRequests = currentState.specialRequests.takeIf { it.isNotBlank() }
                    )
                    orderRepository.addOrderItemToOrder(newOrderItem)
                    _sideEffect.emit(AddItemDetailsSideEffect.NavigateBack)
                } else {
                    _uiState.update { it.copy(errorMessage = "order_info_missing_error") }
                }
            } catch (e: Exception) {
                _uiState.update { it.copy(errorMessage = "error_saving_item_error") }
                Log.e("AddItemDetailsVM", "Error saving item", e)
            } finally {
                _uiState.update { it.copy(isSaving = false) }
            }
        }
    }
}

================
File: ui/feature/login/LoginScreen.kt
================
package com.example.lab1.ui.feature.login

import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.flowWithLifecycle
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.compose.ui.res.stringResource
import com.example.lab1.R
import java.util.Locale

@Composable
fun LoginScreen(
    onLoginSuccess: () -> Unit,
    onNavigateToRegister: () -> Unit,
    loginViewModel: LoginViewModel = hiltViewModel()
) {
    val currentLanguage = Locale.getDefault().language
    val loginTitleString = stringResource(R.string.login_title)
    Log.d("LoginScreen", "Composing. Current Locale.getDefault(): $currentLanguage. Login title: $loginTitleString")

    val uiState by loginViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(loginViewModel.sideEffect, lifecycleOwner) {
        loginViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collect { effect ->
            when (effect) {
                is LoginSideEffect.NavigateToMainApp -> {
                    Log.d("LoginScreen", "SideEffect: NavigateToMainApp received")
                    onLoginSuccess()
                }
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp)
                .safeDrawingPadding()
                .padding(horizontal = 16.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(loginTitleString, style = MaterialTheme.typography.headlineMedium)
            Spacer(modifier = Modifier.height(16.dp))

            if (uiState.errorMessage != null) {
                Text(
                    text = when (uiState.errorMessage) {
                        "username_password_required_error" -> stringResource(R.string.username_password_required_error)
                        "invalid_username_or_password_error" -> stringResource(R.string.invalid_username_or_password_error)
                        else -> uiState.errorMessage!!
                    },
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            OutlinedTextField(
                value = uiState.username,
                onValueChange = { loginViewModel.onAction(LoginUiAction.UsernameChanged(it)) },
                label = { Text(stringResource(R.string.username_label)) },
                singleLine = true,
                modifier = Modifier.fillMaxWidth(),
                isError = uiState.errorMessage != null,
                enabled = !uiState.isLoading
            )
            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = uiState.password,
                onValueChange = { loginViewModel.onAction(LoginUiAction.PasswordChanged(it)) },
                label = { Text(stringResource(R.string.password_label)) },
                singleLine = true,
                visualTransformation = if (uiState.isPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                trailingIcon = {
                    val image = if (uiState.isPasswordVisible)
                        Icons.Filled.Visibility
                    else Icons.Filled.VisibilityOff
                    val description =
                        if (uiState.isPasswordVisible) stringResource(R.string.hide_password_desc) else stringResource(R.string.show_password_desc)

                    IconButton(
                        onClick = { loginViewModel.onAction(LoginUiAction.TogglePasswordVisibility) },
                        enabled = !uiState.isLoading
                    ) {
                        Icon(imageVector = image, description)
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                isError = uiState.errorMessage != null,
                enabled = !uiState.isLoading
            )
            Spacer(modifier = Modifier.height(32.dp))

            Button(
                onClick = {
                    Log.d("LoginScreen", "Login button clicked, dispatching LoginClicked action")
                    loginViewModel.onAction(LoginUiAction.LoginClicked)
                },
                enabled = uiState.isLoginEnabled && !uiState.isLoading,
                modifier = Modifier.fillMaxWidth()
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        color = MaterialTheme.colorScheme.onPrimary
                    )
                } else {
                    Text(stringResource(R.string.login_button_text))
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            TextButton(
                onClick = onNavigateToRegister,
                enabled = !uiState.isLoading
            ) {
                Text(stringResource(R.string.register_prompt))
            }
        }
    }
}

================
File: ui/feature/login/LoginViewModel.kt
================
package com.example.lab1.ui.feature.login

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.repository.AuthRepository
import com.example.lab1.data.repository.AuthResult
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class LoginScreenState(
    val username: String = "",
    val password: String = "",
    val isPasswordVisible: Boolean = false,
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isLoginEnabled: Boolean = false
)

sealed class LoginUiAction {
    data class UsernameChanged(val username: String) : LoginUiAction()
    data class PasswordChanged(val password: String) : LoginUiAction()
    data object TogglePasswordVisibility : LoginUiAction()
    data object LoginClicked : LoginUiAction()
    data object ErrorMessageDismissed : LoginUiAction()
}

sealed class LoginSideEffect {
    data object NavigateToMainApp : LoginSideEffect()
}

@HiltViewModel
class LoginViewModel @Inject constructor(
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(LoginScreenState())
    val uiState: StateFlow<LoginScreenState> = _uiState.asStateFlow()

    private val _sideEffect = MutableSharedFlow<LoginSideEffect>()
    val sideEffect: SharedFlow<LoginSideEffect> = _sideEffect.asSharedFlow()

    fun onAction(action: LoginUiAction) {
        when (action) {
            is LoginUiAction.UsernameChanged -> {
                _uiState.update { currentState ->
                    val newUsername = action.username
                    currentState.copy(
                        username = newUsername,
                        errorMessage = null,
                        isLoginEnabled = newUsername.isNotBlank() && currentState.password.isNotBlank()
                    )
                }
            }

            is LoginUiAction.PasswordChanged -> {
                _uiState.update { currentState ->
                    val newPassword = action.password
                    currentState.copy(
                        password = newPassword,
                        errorMessage = null,
                        isLoginEnabled = currentState.username.isNotBlank() && newPassword.isNotBlank()
                    )
                }
            }

            LoginUiAction.TogglePasswordVisibility -> {
                _uiState.update { currentState ->
                    currentState.copy(isPasswordVisible = !currentState.isPasswordVisible)
                }
            }

            LoginUiAction.LoginClicked -> {
                attemptLogin()
            }

            LoginUiAction.ErrorMessageDismissed -> {
                _uiState.update { it.copy(errorMessage = null) }
            }
        }
    }

    private fun attemptLogin() {
        val currentState = _uiState.value

        if (!currentState.isLoginEnabled) {
            _uiState.update { it.copy(errorMessage = "username_password_required_error") }
            return
        }

        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }

            when (val result = authRepository.login(currentState.username, currentState.password)) {
                is AuthResult.Success -> {
                    _uiState.update { it.copy(isLoading = false) }
                    _sideEffect.emit(LoginSideEffect.NavigateToMainApp)
                }

                is AuthResult.Error -> {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            errorMessage = result.message
                        )
                    }
                }
            }
        }
    }
}

================
File: ui/feature/menu/MenuScreen.kt
================
package com.example.lab1.ui.feature.menu

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.lifecycle.flowWithLifecycle
import com.example.lab1.ui.components.MenuItemCard 
import androidx.compose.ui.res.stringResource
import com.example.lab1.R
import android.content.Intent
import androidx.compose.ui.platform.LocalContext
import com.example.lab1.ui.feature.dailyspecials.DailySpecialsActivity

@Composable
fun MenuScreen(
    onNavigateToNewOrderItemDetails: (menuItemId: String) -> Unit,
    menuViewModel: MenuViewModel = hiltViewModel()
) {
    val uiState by menuViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current
    val context = LocalContext.current

    LaunchedEffect(menuViewModel.sideEffect, lifecycleOwner) {
        menuViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collect { effect ->
            when (effect) {
                is MenuScreenSideEffect.NavigateToNewOrderItemDetails -> {
                    onNavigateToNewOrderItemDetails(effect.menuItemId)
                }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp) 
    ) {
        Button(
            onClick = {
                context.startActivity(Intent(context, DailySpecialsActivity::class.java))
            },
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp)
        ) {
            Text(stringResource(R.string.view_daily_specials_button))
        }

        if (uiState.isLoading) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                CircularProgressIndicator()
                Text(stringResource(R.string.loading_menu_text), modifier = Modifier.padding(start = 8.dp))
            }
        } else if (uiState.errorMessage != null) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text(
                    text = when (uiState.errorMessage) {
                        "error_fetching_menu_error" -> stringResource(R.string.error_fetching_menu_error)
                        else -> stringResource(R.string.generic_error_text, uiState.errorMessage!!) // Fallback
                    },
                    color = MaterialTheme.colorScheme.error,
                    modifier = Modifier.padding(16.dp)
                )
            }
        } else if (uiState.menuItems.isEmpty()) {
            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                Text(stringResource(R.string.no_menu_items_text), modifier = Modifier.padding(16.dp))
            }
        } else {
            LazyColumn(
                modifier = Modifier.fillMaxSize(),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                items(uiState.menuItems, key = { item -> item.id }) { menuItem ->
                    Box(modifier = Modifier.clickable {
                        menuViewModel.onAction(MenuScreenAction.MenuItemClicked(menuItem.id))
                    }) {
                        MenuItemCard( 
                            itemNameKey = menuItem.nameKey,
                            itemDescriptionKey = menuItem.descriptionKey,
                            price = menuItem.price 
                        )
                    }
                }
            }
        }
    }
}

================
File: ui/feature/menu/MenuViewModel.kt
================
package com.example.lab1.ui.feature.menu

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.model.MenuItem 
import com.example.lab1.data.repository.OrderRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class MenuScreenState(
    val menuItems: List<MenuItem> = emptyList(),
    val isLoading: Boolean = true,
    val errorMessage: String? = null,
    val selectedCategory: String? = null 
)

sealed class MenuScreenAction {
    data class MenuItemClicked(val menuItemId: String) : MenuScreenAction()
    data class FilterByCategory(val category: String?) : MenuScreenAction() 
}

sealed class MenuScreenSideEffect {
    data class NavigateToNewOrderItemDetails(val menuItemId: String) : MenuScreenSideEffect()
}

@HiltViewModel
class MenuViewModel @Inject constructor(
    private val orderRepository: OrderRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(MenuScreenState())
    val uiState: StateFlow<MenuScreenState> = _uiState.asStateFlow()

    private val _sideEffect = MutableSharedFlow<MenuScreenSideEffect>()
    val sideEffect: SharedFlow<MenuScreenSideEffect> = _sideEffect.asSharedFlow()

    init {
        fetchMenuItems()
    }

    private fun fetchMenuItems(category: String? = null) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null, selectedCategory = category) }
            orderRepository.getAllMenuItems()
                .catch { e ->
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            errorMessage = "error_fetching_menu_error"
                        )
                    }
                }
                .collectLatest { items ->
                    val filteredItems = if (category == null) {
                        items
                    } else {
                        items.filter { it.category.equals(category, ignoreCase = true) }
                    }
                    _uiState.update {
                        it.copy(
                            menuItems = filteredItems,
                            isLoading = false
                        )
                    }
                }
        }
    }

    fun onAction(action: MenuScreenAction) {
        when (action) {
            is MenuScreenAction.MenuItemClicked -> {
                viewModelScope.launch {
                    _sideEffect.emit(MenuScreenSideEffect.NavigateToNewOrderItemDetails(action.menuItemId))
                }
            }
            is MenuScreenAction.FilterByCategory -> {
                fetchMenuItems(action.category)
            }
        }
    }
}

================
File: ui/feature/order/OrderScreen.kt
================
package com.example.lab1.ui.feature.order

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.LocalLifecycleOwner
import com.example.lab1.data.model.OrderItemEntity
import kotlinx.coroutines.flow.collectLatest
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.flowWithLifecycle
import androidx.navigation.NavHostController
import com.example.lab1.R
import com.example.lab1.ui.navigation.AppDestinations
import androidx.compose.ui.res.stringResource


@Composable
fun OrderScreen(
    innerNavController: NavHostController, 
    orderViewModel: OrderViewModel = hiltViewModel() 
) {
    val uiState by orderViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(orderViewModel.sideEffect, lifecycleOwner) {
        orderViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collectLatest { effect ->
            when (effect) {
                is OrderScreenSideEffect.NavigateToEditOrderItem -> {
                    innerNavController.navigate(
                        AppDestinations.EDIT_ORDER_ITEM_DETAILS_ROUTE.replace(
                            "{${AppDestinations.ARG_ITEM_ID}}",
                            effect.orderItemId.toString()
                        )
                    )
                }
                OrderScreenSideEffect.NavigateToMenuScreen -> {
                    val activeOrderId = uiState.currentOrder?.orderId 
                    if (activeOrderId != null) {
                        innerNavController.navigate(
                            AppDestinations.MENU_SCREEN_WITH_ORDER_ROUTE.replace(
                                "{${AppDestinations.ARG_ACTIVE_ORDER_ID}}",
                                activeOrderId.toString()
                            )
                        )
                    }
                }
            }
        }
    }

    Scaffold(
        floatingActionButton = {
            FloatingActionButton(onClick = { orderViewModel.onAction(OrderScreenAction.FabClicked) }) {
                Icon(Icons.Filled.Add, contentDescription = stringResource(R.string.add_items_to_order_fab_desc))
            }
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues) 
                .safeDrawingPadding()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                uiState.currentOrder?.let { order ->
                    Text(
                        text = stringResource(R.string.order_id_table_text, order.orderId, order.tableNumber),
                        fontSize = 20.sp,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.primary
                    )
                } ?: Text(
                    text = stringResource(R.string.no_active_order_text),
                    fontSize = 20.sp,
                    fontWeight = FontWeight.Bold
                )
                Button(onClick = { orderViewModel.onAction(OrderScreenAction.CreateNewOrder) }) {
                    Text(stringResource(R.string.new_order_button))
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (uiState.isLoadingOrder) {
                Box(modifier = Modifier.fillMaxWidth(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                    Text(stringResource(R.string.loading_order_text), modifier = Modifier.padding(start = 8.dp))
                }
            }

            uiState.errorMessage?.let {
                Text(
                    text = stringResource(R.string.generic_error_text, it),
                    color = MaterialTheme.colorScheme.error,
                    modifier = Modifier.padding(vertical = 8.dp)
                )
            }

            if (uiState.currentOrder != null && uiState.isLoadingItems) {
                Box(modifier = Modifier.fillMaxWidth().padding(top=16.dp), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                    Text(stringResource(R.string.loading_items_text), modifier = Modifier.padding(start = 8.dp))
                }
            } else if (uiState.currentOrder == null && !uiState.isLoadingOrder) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text(stringResource(R.string.create_new_order_prompt), fontSize = 18.sp)
                }
            } else if (uiState.currentOrderItems.isEmpty() && uiState.currentOrder != null) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    Text(stringResource(R.string.empty_order_prompt), fontSize = 18.sp)
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize(),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(uiState.currentOrderItems, key = { item -> item.orderItemId }) { orderItem ->
                        OrderItemRow(
                            orderItem = orderItem,
                            onClick = {
                                orderViewModel.onAction(OrderScreenAction.OrderItemClicked(orderItem.orderItemId))
                            },
                            onDelete = {
                                orderViewModel.onAction(OrderScreenAction.OrderItemSwipedToDelete(orderItem))
                            }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun OrderItemRow(
    orderItem: OrderItemEntity,
    onClick: () -> Unit,
    onDelete: () -> Unit
) {
    val dismissState = rememberSwipeToDismissBoxState(
        confirmValueChange = {
            if (it == SwipeToDismissBoxValue.EndToStart) { 
                onDelete()
                true 
            } else {
                false
            }
        }
    )

    SwipeToDismissBox(
        state = dismissState,
        backgroundContent = {
            val color = when(dismissState.dismissDirection) {
                SwipeToDismissBoxValue.EndToStart -> MaterialTheme.colorScheme.errorContainer
                else -> Color.Transparent
            }
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .background(color)
                    .padding(12.dp),
                contentAlignment = Alignment.CenterEnd 
            ) {
                Icon(
                    Icons.Filled.Delete,
                    contentDescription = stringResource(R.string.delete_item_desc),
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        },
        enableDismissFromStartToEnd = false, 
        enableDismissFromEndToStart = true
    ) {
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .clickable(onClick = onClick),
            shape = MaterialTheme.shapes.medium
        ) {
            Row(
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(orderItem.itemName, style = MaterialTheme.typography.titleMedium)
                    Text(
                        stringResource(R.string.order_item_details_text, orderItem.quantity, orderItem.itemPrice),
                        style = MaterialTheme.typography.bodySmall
                    )
                    orderItem.specialRequests?.takeIf { it.isNotBlank() }?.let {
                        Text(stringResource(R.string.notes_label, it), style = MaterialTheme.typography.bodySmall, fontStyle = androidx.compose.ui.text.font.FontStyle.Italic)
                    }
                }
            }
        }
    }
}

================
File: ui/feature/order/OrderViewModel.kt
================
package com.example.lab1.ui.feature.order

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.model.OrderEntity
import com.example.lab1.data.model.OrderItemEntity
import com.example.lab1.data.repository.OrderRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.filterNotNull
import kotlinx.coroutines.flow.flatMapLatest
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class OrderScreenState(
    val currentOrder: OrderEntity? = null,
    val currentOrderItems: List<OrderItemEntity> = emptyList(),
    val isLoadingOrder: Boolean = true,
    val isLoadingItems: Boolean = false, 
    val errorMessage: String? = null,
    val showMenuScreen: Boolean = false 
)

sealed class OrderScreenAction {
    data object CreateNewOrder : OrderScreenAction()
    data class OrderItemClicked(val orderItemId: Long) : OrderScreenAction()
    data class OrderItemSwipedToDelete(val orderItemEntity: OrderItemEntity) : OrderScreenAction()
    data object FabClicked : OrderScreenAction() 
    data object MenuScreenDismissed : OrderScreenAction() 
    data object LoadActiveOrder : OrderScreenAction() 
}

sealed class OrderScreenSideEffect {
    data class NavigateToEditOrderItem(val orderItemId: Long) : OrderScreenSideEffect()
    data object NavigateToMenuScreen : OrderScreenSideEffect()
}

@OptIn(ExperimentalCoroutinesApi::class)
@HiltViewModel
class OrderViewModel @Inject constructor(
    private val orderRepository: OrderRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(OrderScreenState())
    val uiState: StateFlow<OrderScreenState> = _uiState.asStateFlow()

    private val _sideEffect = MutableSharedFlow<OrderScreenSideEffect>()
    val sideEffect: SharedFlow<OrderScreenSideEffect> = _sideEffect.asSharedFlow()

    private val activeOrderIdFlow = MutableStateFlow<Long?>(null)

    init {
        loadLatestActiveOrder()
        viewModelScope.launch {
            activeOrderIdFlow.filterNotNull().flatMapLatest { orderId ->
                _uiState.update { it.copy(isLoadingItems = true) }
                orderRepository.getOrderItemsForOrder(orderId)
            }.collectLatest { items ->
                _uiState.update {
                    it.copy(
                        currentOrderItems = items,
                        isLoadingItems = false,
                        errorMessage = null
                    )
                }
            }
        }
    }

    private fun loadLatestActiveOrder() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoadingOrder = true) }
            orderRepository.getLatestActiveOrder().collectLatest { order ->
                _uiState.update { it.copy(currentOrder = order, isLoadingOrder = false) }
                activeOrderIdFlow.value = order?.orderId 
                if (order == null) { 
                    _uiState.update { it.copy(currentOrderItems = emptyList(), isLoadingItems = false) }
                }
            }
        }
    }


    fun onAction(action: OrderScreenAction) {
        when (action) {
            OrderScreenAction.LoadActiveOrder -> {
                loadLatestActiveOrder() 
            }
            OrderScreenAction.CreateNewOrder -> {
                viewModelScope.launch {
                    _uiState.update { it.copy(isLoadingOrder = true) }
                    val newOrderId = orderRepository.createNewOrder(tableNumber = _uiState.value.currentOrder?.tableNumber?.plus(1) ?: 1)
                    activeOrderIdFlow.value = newOrderId
                    orderRepository.getOrderById(newOrderId).collectLatest { newOrder ->
                        _uiState.update { it.copy(currentOrder = newOrder, isLoadingOrder = false, currentOrderItems = emptyList()) }
                    }
                }
            }
            is OrderScreenAction.OrderItemClicked -> {
                viewModelScope.launch {
                    _sideEffect.emit(OrderScreenSideEffect.NavigateToEditOrderItem(action.orderItemId))
                }
            }
            is OrderScreenAction.OrderItemSwipedToDelete -> {
                viewModelScope.launch {
                    orderRepository.deleteOrderItem(action.orderItemEntity)
                }
            }
            OrderScreenAction.FabClicked -> {
                if (_uiState.value.currentOrder == null) {
                    _uiState.update { it.copy(errorMessage = "R.string.select_order_first_prompt") }
                } else {
                    viewModelScope.launch { _sideEffect.emit(OrderScreenSideEffect.NavigateToMenuScreen) }
                }
            }
            OrderScreenAction.MenuScreenDismissed -> {
                _uiState.update { it.copy(showMenuScreen = false) }
            }
        }
    }
}

================
File: ui/feature/orderhistory/OrderHistoryActivity.kt
================
package com.example.lab1.ui.feature.orderhistory

import android.os.Bundle
import android.view.View
import androidx.activity.ComponentActivity
import androidx.core.view.ViewCompat
import androidx.core.view.WindowCompat
import androidx.core.view.WindowInsetsCompat
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.lab1.R

class OrderHistoryActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        WindowCompat.setDecorFitsSystemWindows(window, false)
        setContentView(R.layout.activity_order_history)

        val rootView = findViewById<View>(R.id.order_history_root_layout)
        val recyclerView = findViewById<RecyclerView>(R.id.recyclerViewOrderHistory)

        // Store original padding values from XML for the root layout
        val originalRootPaddingLeft = rootView.paddingLeft
        val originalRootPaddingTop = rootView.paddingTop
        val originalRootPaddingRight = rootView.paddingRight
        val originalRootPaddingBottom = rootView.paddingBottom

        ViewCompat.setOnApplyWindowInsetsListener(rootView) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            // Apply original XML padding + system bar insets to the root
            v.setPadding(
                originalRootPaddingLeft + systemBars.left,
                originalRootPaddingTop + systemBars.top,
                originalRootPaddingRight + systemBars.right,
                originalRootPaddingBottom + systemBars.bottom
            )
            // Return a new WindowInsetsCompat that consumes only the system bars for child views
            // This is important so that RecyclerView's own padding (set in XML) is respected relative to the new root padding
            WindowInsetsCompat.Builder(insets).setInsets(
                WindowInsetsCompat.Type.systemBars(),
                androidx.core.graphics.Insets.of(0,0,0,0) // Consume system bars
            ).build()
        }

        // Setup RecyclerView
        recyclerView.adapter = OrderHistoryAdapter(getMockOrderHistoryData())
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.setHasFixedSize(true) // Optimization if item sizes don't change
    }

    private fun getMockOrderHistoryData(): List<OrderHistoryItem> {
        return listOf(
            OrderHistoryItem("78901", "2023-10-25", "$32.50", "Paid"),
            OrderHistoryItem("78902", "2023-10-24", "$120.00", "Paid"),
            OrderHistoryItem("78903", "2023-10-23", "$15.75", "Cancelled"),
            OrderHistoryItem("78904", "2023-10-22", "$88.10", "Paid"),
            OrderHistoryItem("78905", "2023-10-21", "$61.30", "Paid"),
            OrderHistoryItem("78906", "2023-10-20", "$42.00", "Paid"),
            OrderHistoryItem("78907", "2023-10-19", "$9.50", "Cancelled"),
            OrderHistoryItem("78908", "2023-10-18", "$75.25", "Paid"),
            OrderHistoryItem("78909", "2023-10-17", "$23.00", "Paid"),
            OrderHistoryItem("78910", "2023-10-16", "$50.50", "Paid")
        )
    }
}

================
File: ui/feature/orderhistory/OrderHistoryAdapter.kt
================
package com.example.lab1.ui.feature.orderhistory

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
import com.example.lab1.R

class OrderHistoryAdapter(
    private val orderHistoryList: List<OrderHistoryItem>
) : RecyclerView.Adapter<OrderHistoryAdapter.OrderHistoryViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): OrderHistoryViewHolder {
        val itemView = LayoutInflater.from(parent.context)
            .inflate(R.layout.list_item_order_history, parent, false)
        return OrderHistoryViewHolder(itemView)
    }

    override fun onBindViewHolder(holder: OrderHistoryViewHolder, position: Int) {
        val currentItem = orderHistoryList[position]
        val context = holder.itemView.context

        holder.orderIdTextView.text = context.getString(R.string.order_history_item_id_label, currentItem.orderId)
        holder.orderDateTextView.text = context.getString(R.string.order_history_item_date_label, currentItem.date)
        holder.orderTotalTextView.text = context.getString(R.string.order_history_item_total_label, currentItem.totalAmount)
        holder.orderStatusTextView.text = context.getString(R.string.order_history_item_status_label, currentItem.status)
    }

    override fun getItemCount() = orderHistoryList.size

    class OrderHistoryViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        val orderIdTextView: TextView = itemView.findViewById(R.id.textViewOrderId)
        val orderDateTextView: TextView = itemView.findViewById(R.id.textViewOrderDate)
        val orderTotalTextView: TextView = itemView.findViewById(R.id.textViewOrderTotal)
        val orderStatusTextView: TextView = itemView.findViewById(R.id.textViewOrderStatus)
    }
}

================
File: ui/feature/orderhistory/OrderHistoryItem.kt
================
package com.example.lab1.ui.feature.orderhistory

data class OrderHistoryItem(
    val orderId: String,
    val date: String,
    val totalAmount: String,
    val status: String
)

================
File: ui/feature/profile/ProfileScreen.kt
================
package com.example.lab1.ui.feature.profile

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.flowWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import coil.request.ImageRequest
import com.example.lab1.R
import com.example.lab1.data.repository.MockProfileRepository
import androidx.compose.ui.res.stringResource

@Composable
fun ProfileScreen(
    onNavigateToLogin: () -> Unit,
    profileViewModel: ProfileViewModel = hiltViewModel()
) {
    val uiState by profileViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(profileViewModel.sideEffect, lifecycleOwner) {
        profileViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collect { effect ->
            when (effect) {
                ProfileScreenSideEffect.NavigateToLogin -> {
                    onNavigateToLogin()
                }
            }
        }
    }

    Surface(modifier = Modifier.fillMaxSize()) {
        if (uiState.isLoading) {
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                CircularProgressIndicator()
            }
        } else if (uiState.errorMessage != null) {
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Text(
                    text = when (uiState.errorMessage) {
                        "user_profile_not_found_error" -> stringResource(R.string.user_profile_not_found_error)
                        else -> stringResource(R.string.generic_error_text, uiState.errorMessage!!) // Fallback generic error
                    },
                    color = MaterialTheme.colorScheme.error,
                    modifier = Modifier.padding(16.dp)
                )
            }
        } else if (uiState.userProfile != null) {
            val userProfile = uiState.userProfile!!
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                AsyncImage(
                    model = ImageRequest.Builder(LocalContext.current)
                        .data(userProfile.profileImageUrl)
                        .crossfade(true)
                        .error(R.drawable.ic_launcher_foreground)
                        .placeholder(R.drawable.ic_launcher_foreground)
                        .build(),
                    contentDescription = stringResource(R.string.profile_picture_desc),
                    modifier = Modifier
                        .size(120.dp)
                        .clip(CircleShape),
                    contentScale = ContentScale.Crop
                )
                Text(
                    text = userProfile.username,
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                ProfileInfoRow(label = stringResource(R.string.email_label), value = userProfile.email)
                userProfile.dateOfBirth?.let {
                    ProfileInfoRow(
                        label = stringResource(R.string.dob_label),
                        value = it
                    )
                }
                ProfileInfoRow(label = stringResource(R.string.member_since_label), value = userProfile.memberSince)
                Spacer(modifier = Modifier.weight(1f))
                Button(
                    onClick = { profileViewModel.onAction(ProfileScreenAction.LogoutClicked) },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(stringResource(R.string.logout_button))
                }
            }
        } else {
            Box(contentAlignment = Alignment.Center, modifier = Modifier.fillMaxSize()) {
                Text(stringResource(R.string.no_profile_data_text))
            }
        }
    }
}

@Composable
fun ProfileInfoRow(label: String, value: String) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(text = label, fontWeight = FontWeight.SemiBold, fontSize = 16.sp)
        Text(text = value, fontSize = 16.sp)
    }
}

================
File: ui/feature/profile/ProfileViewModel.kt
================
package com.example.lab1.ui.feature.profile

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.repository.AuthRepository
import com.example.lab1.util.DataResult
import com.example.lab1.data.repository.ProfileRepository
import com.example.lab1.data.repository.UserProfile
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class ProfileScreenState(
    val userProfile: UserProfile? = null,
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)

sealed class ProfileScreenAction {
    data object LoadProfile : ProfileScreenAction()
    data object LogoutClicked : ProfileScreenAction()
}

sealed class ProfileScreenSideEffect {
    data object NavigateToLogin : ProfileScreenSideEffect()
}

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val profileRepository: ProfileRepository,
    private val authRepository: AuthRepository
) : ViewModel() {
    private val _uiState = MutableStateFlow(ProfileScreenState())
    val uiState: StateFlow<ProfileScreenState> = _uiState.asStateFlow()

    private val _sideEffect = kotlinx.coroutines.flow.MutableSharedFlow<ProfileScreenSideEffect>()
    val sideEffect: kotlinx.coroutines.flow.SharedFlow<ProfileScreenSideEffect> =
        _sideEffect.asSharedFlow()

    init {
        onAction(ProfileScreenAction.LoadProfile)
    }

    fun onAction(action: ProfileScreenAction) {
        when (action) {
            ProfileScreenAction.LoadProfile -> {
                fetchUserProfile()
            }

            ProfileScreenAction.LogoutClicked -> {
                viewModelScope.launch {
                    authRepository.logout()
                    _sideEffect.emit(ProfileScreenSideEffect.NavigateToLogin)
                }
            }
        }
    }

    private fun fetchUserProfile() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            
            val result = profileRepository.getUserProfile("testuser")

            when (result) {
                is DataResult.Success -> {
                    _uiState.update {
                        it.copy(
                            userProfile = result.data,
                            isLoading = false
                        )
                    }
                }

                is DataResult.Error -> {
                    _uiState.update {
                        it.copy(
                            errorMessage = result.message,
                            isLoading = false
                        )
                    }
                }

                is DataResult.Loading -> {
                    _uiState.update { it.copy(isLoading = true) }
                }
            }
        }
    }
}

================
File: ui/feature/register/RegistrationScreen.kt
================
package com.example.lab1.ui.feature.register

import android.util.Log
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Visibility
import androidx.compose.material.icons.filled.VisibilityOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.flowWithLifecycle
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.lab1.ui.components.AppTopAppBar
import androidx.compose.ui.res.stringResource
import com.example.lab1.R

@Composable
fun RegistrationScreen(
    onRegistrationSuccess: () -> Unit,
    onNavigateBackToLogin: () -> Unit,
    registrationViewModel: RegistrationViewModel = hiltViewModel()
) {
    val uiState by registrationViewModel.uiState.collectAsState()
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(registrationViewModel.sideEffect, lifecycleOwner) {
        registrationViewModel.sideEffect.flowWithLifecycle(
            lifecycleOwner.lifecycle,
            Lifecycle.State.STARTED
        ).collect { effect ->
            when (effect) {
                is RegistrationSideEffect.NavigateToMainApp -> {
                    Log.d("RegistrationScreen", "SideEffect: NavigateToMainApp received")
                    onRegistrationSuccess()
                }
            }
        }
    }

    Scaffold(
        topBar = {
            AppTopAppBar(
                title = stringResource(R.string.register_title),
                canNavigateBack = true,
                onNavigateBack = onNavigateBackToLogin
            )
        }
    ) { innerPadding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(innerPadding)
                .padding(vertical = 16.dp, horizontal = 32.dp),
            verticalArrangement = Arrangement.Center,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            if (uiState.errorMessage != null) {
                Text(
                    text = when (uiState.errorMessage) {
                        "fill_all_fields_and_accept_policy_error" -> stringResource(R.string.fill_all_fields_and_accept_policy_error)
                        "username_too_short_error" -> stringResource(R.string.username_too_short_error)
                        "password_too_short_error" -> stringResource(R.string.password_too_short_error)
                        "username_already_exists_error" -> stringResource(R.string.username_already_exists_error)
                        else -> uiState.errorMessage!!
                    },
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodySmall,
                    modifier = Modifier.padding(bottom = 8.dp)
                )
            }
            Spacer(modifier = Modifier.height(8.dp))

            OutlinedTextField(
                value = uiState.username,
                onValueChange = {
                    registrationViewModel.onAction(
                        RegistrationUiAction.UsernameChanged(
                            it
                        )
                    )
                },
                label = { Text(stringResource(R.string.username_label)) },
                singleLine = true,
                modifier = Modifier.fillMaxWidth(),
                isError = uiState.errorMessage?.let { it == "username_too_short_error" || it == "username_already_exists_error" } == true,
                enabled = !uiState.isLoading
            )
            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = uiState.password,
                onValueChange = {
                    registrationViewModel.onAction(
                        RegistrationUiAction.PasswordChanged(
                            it
                        )
                    )
                },
                label = { Text(stringResource(R.string.password_label)) },
                singleLine = true,
                visualTransformation = if (uiState.isPasswordVisible) VisualTransformation.None else PasswordVisualTransformation(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),
                trailingIcon = {
                    val image =
                        if (uiState.isPasswordVisible) Icons.Filled.Visibility else Icons.Filled.VisibilityOff
                    val description =
                        if (uiState.isPasswordVisible) stringResource(R.string.hide_password_desc) else stringResource(R.string.show_password_desc)
                    IconButton(
                        onClick = { registrationViewModel.onAction(RegistrationUiAction.TogglePasswordVisibility) },
                        enabled = !uiState.isLoading
                    ) {
                        Icon(imageVector = image, contentDescription = description)
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                isError = uiState.errorMessage == "password_too_short_error",
                enabled = !uiState.isLoading
            )
            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = uiState.dateOfBirth,
                onValueChange = {
                    registrationViewModel.onAction(
                        RegistrationUiAction.DateOfBirthChanged(
                            it
                        )
                    )
                },
                label = { Text(stringResource(R.string.dob_hint)) },
                singleLine = true,
                modifier = Modifier.fillMaxWidth(),
                isError = uiState.errorMessage?.contains(
                    stringResource(R.string.dob_hint)
                ) == true,
                enabled = !uiState.isLoading
            )
            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
            ) {
                Checkbox(
                    checked = uiState.isPrivacyPolicyAccepted,
                    onCheckedChange = {
                        registrationViewModel.onAction(
                            RegistrationUiAction.PrivacyPolicyAcceptedChanged(
                                it
                            )
                        )
                    },
                    enabled = !uiState.isLoading
                )
                Text(
                    text = stringResource(R.string.privacy_policy_accept),
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(start = 8.dp)
                )
            }
            Spacer(modifier = Modifier.height(32.dp))

            Button(
                onClick = {
                    Log.d(
                        "RegistrationScreen",
                        "Register button clicked, dispatching RegisterClicked action"
                    )
                    registrationViewModel.onAction(RegistrationUiAction.RegisterClicked)
                },
                enabled = uiState.isRegisterEnabled && !uiState.isLoading,
                modifier = Modifier.fillMaxWidth()
            ) {
                if (uiState.isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        color = MaterialTheme.colorScheme.onPrimary
                    )
                } else {
                    Text(stringResource(R.string.register_button_text))
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            TextButton(
                onClick = onNavigateBackToLogin,
                enabled = !uiState.isLoading
            ) {
                Text(stringResource(R.string.login_prompt))
            }
        }
    }
}

================
File: ui/feature/register/RegistrationViewModel.kt
================
package com.example.lab1.ui.feature.register

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.repository.AuthRepository
import com.example.lab1.data.repository.AuthResult
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

data class RegistrationScreenState(
    val username: String = "",
    val password: String = "",
    val isPasswordVisible: Boolean = false,
    val dateOfBirth: String = "",
    val isPrivacyPolicyAccepted: Boolean = false,
    val isLoading: Boolean = false,
    val errorMessage: String? = null,
    val isRegisterEnabled: Boolean = false
)

sealed class RegistrationUiAction {
    data class UsernameChanged(val username: String) : RegistrationUiAction()
    data class PasswordChanged(val password: String) : RegistrationUiAction()
    data object TogglePasswordVisibility : RegistrationUiAction()
    data class DateOfBirthChanged(val dob: String) : RegistrationUiAction()
    data class PrivacyPolicyAcceptedChanged(val isAccepted: Boolean) : RegistrationUiAction()
    data object RegisterClicked : RegistrationUiAction()
    data object ErrorMessageDismissed : RegistrationUiAction()
}

sealed class RegistrationSideEffect {
    data object NavigateToMainApp : RegistrationSideEffect()
}

@HiltViewModel
class RegistrationViewModel @Inject constructor(
    private val authRepository: AuthRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(RegistrationScreenState())
    val uiState: StateFlow<RegistrationScreenState> = _uiState.asStateFlow()

    private val _sideEffect = MutableSharedFlow<RegistrationSideEffect>()
    val sideEffect: SharedFlow<RegistrationSideEffect> = _sideEffect.asSharedFlow()

    init {
        updateRegisterButtonState(_uiState.value)
    }

    fun onAction(action: RegistrationUiAction) {
        when (action) {
            is RegistrationUiAction.UsernameChanged -> {
                _uiState.update { currentState ->
                    currentState.copy(
                        username = action.username,
                        errorMessage = null
                    ).also { updateRegisterButtonState(it) }
                }
            }

            is RegistrationUiAction.PasswordChanged -> {
                _uiState.update { currentState ->
                    currentState.copy(
                        password = action.password,
                        errorMessage = null
                    ).also { updateRegisterButtonState(it) }
                }
            }

            RegistrationUiAction.TogglePasswordVisibility -> {
                _uiState.update { it.copy(isPasswordVisible = !it.isPasswordVisible) }
            }

            is RegistrationUiAction.DateOfBirthChanged -> {
                _uiState.update { currentState ->
                    currentState.copy(
                        dateOfBirth = action.dob,
                        errorMessage = null
                    ).also { updateRegisterButtonState(it) }
                }
            }

            is RegistrationUiAction.PrivacyPolicyAcceptedChanged -> {
                _uiState.update { currentState ->
                    currentState.copy(
                        isPrivacyPolicyAccepted = action.isAccepted,
                        errorMessage = null
                    ).also { updateRegisterButtonState(it) }
                }
            }

            RegistrationUiAction.RegisterClicked -> {
                attemptRegistration()
            }

            RegistrationUiAction.ErrorMessageDismissed -> {
                _uiState.update { it.copy(errorMessage = null) }
            }
        }
    }

    private fun updateRegisterButtonState(currentState: RegistrationScreenState) {
        val isEnabled = currentState.username.isNotBlank() &&
                currentState.password.isNotBlank() &&
                currentState.dateOfBirth.isNotBlank() &&
                currentState.isPrivacyPolicyAccepted
        _uiState.update { it.copy(isRegisterEnabled = isEnabled) }
    }

    private fun attemptRegistration() {
        val currentState = _uiState.value
        if (!currentState.isRegisterEnabled) {
            _uiState.update { it.copy(errorMessage = "fill_all_fields_and_accept_policy_error") }
            return
        }
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, errorMessage = null) }
            when (val result = authRepository.register(
                username = currentState.username,
                passwordHash = currentState.password,
                dateOfBirth = currentState.dateOfBirth
            )) {
                is AuthResult.Success -> {
                    _uiState.update { it.copy(isLoading = false) }
                    _sideEffect.emit(RegistrationSideEffect.NavigateToMainApp)
                }

                is AuthResult.Error -> {
                    _uiState.update {
                        it.copy(
                            isLoading = false,
                            errorMessage = result.message
                        )
                    }
                }
            }
        }
    }
}

================
File: ui/feature/settings/SettingsScreen.kt
================
package com.example.lab1.ui.feature.settings

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowDropDown
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.lab1.R

@Composable
fun SettingsScreen(
    settingsViewModel: SettingsViewModel = hiltViewModel()
) {
    val notificationsEnabled by settingsViewModel.notificationsEnabled.collectAsState()
    val soundsEnabled by settingsViewModel.soundsEnabled.collectAsState()
    val currentTheme by settingsViewModel.appTheme.collectAsState()
    val currentLanguage by settingsViewModel.appLanguage.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        SettingItemSwitch(
            title = stringResource(R.string.notifications_enabled_label),
            checked = notificationsEnabled,
            onCheckedChange = { settingsViewModel.onNotificationsEnabledChanged(it) }
        )
        SettingItemSwitch(
            title = stringResource(R.string.sounds_enabled_label),
            checked = soundsEnabled,
            onCheckedChange = { settingsViewModel.onSoundsEnabledChanged(it) }
        )
        ThemeSettingItem(
            currentTheme = currentTheme,
            onThemeSelected = { settingsViewModel.onAppThemeChanged(it) }
        )
        LanguageSettingItem(
            currentLanguage = currentLanguage,
            onLanguageSelected = { newLanguage ->
                if (newLanguage != currentLanguage) {
                    settingsViewModel.onAppLanguageChanged(newLanguage)
                }
            }
        )
    }
}

@Composable
fun SettingItemSwitch(
    title: String,
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(title, style = MaterialTheme.typography.bodyLarge)
        Switch(checked = checked, onCheckedChange = onCheckedChange)
    }
}

@Composable
fun ThemeSettingItem(
    currentTheme: String,
    onThemeSelected: (String) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val themes = listOf(
        stringResource(R.string.light_theme),
        stringResource(R.string.dark_theme),
        stringResource(R.string.system_theme)
    )
    // Map display names back to keys for saving
    val themeKeys = listOf("Light", "Dark", "System")


    Column(modifier = Modifier.padding(vertical = 8.dp)) {
        Text(stringResource(R.string.app_theme_label), style = MaterialTheme.typography.bodyLarge)
        Spacer(modifier = Modifier.height(4.dp))
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = when (currentTheme) {
                    "Light" -> stringResource(R.string.light_theme)
                    "Dark" -> stringResource(R.string.dark_theme)
                    else -> stringResource(R.string.system_theme)
                },
                onValueChange = { },
                readOnly = true,
                label = { Text(stringResource(R.string.selected_theme_label)) },
                trailingIcon = { Icon(Icons.Filled.ArrowDropDown, "dropdown") },
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { expanded = true }
            )
            DropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false },
                modifier = Modifier.fillMaxWidth()
            ) {
                themes.forEachIndexed { index, themeName ->
                    DropdownMenuItem(
                        text = { Text(themeName) },
                        onClick = {
                            onThemeSelected(themeKeys[index])
                            expanded = false
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun LanguageSettingItem(
    currentLanguage: String,
    onLanguageSelected: (String) -> Unit
) {
    var expanded by remember { mutableStateOf(false) }
    val languages = listOf(
        "en" to stringResource(R.string.english),
        "uk" to stringResource(R.string.ukrainian)
    )

    Column(modifier = Modifier.padding(vertical = 8.dp)) {
        Text(stringResource(R.string.app_language_label), style = MaterialTheme.typography.bodyLarge)
        Spacer(modifier = Modifier.height(4.dp))
        Box(modifier = Modifier.fillMaxWidth()) {
            OutlinedTextField(
                value = languages.find { it.first == currentLanguage }?.second ?: currentLanguage,
                onValueChange = { },
                readOnly = true,
                label = { Text(stringResource(R.string.selected_language_label)) },
                trailingIcon = { Icon(Icons.Filled.ArrowDropDown, "dropdown") },
                modifier = Modifier
                    .fillMaxWidth()
                    .clickable { expanded = true }
            )
            DropdownMenu(
                expanded = expanded,
                onDismissRequest = { expanded = false },
                modifier = Modifier.fillMaxWidth()
            ) {
                languages.forEach { (langCode, langName) ->
                    DropdownMenuItem(
                        text = { Text(langName) },
                        onClick = {
                            onLanguageSelected(langCode)
                            expanded = false
                        }
                    )
                }
            }
        }
    }
}

================
File: ui/feature/settings/SettingsViewModel.kt
================
package com.example.lab1.ui.feature.settings

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.lab1.data.repository.SettingsRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import javax.inject.Inject
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch

data class SettingsUiState(
    val notificationsEnabled: Boolean = true,
    val soundsEnabled: Boolean = true,
    val appTheme: String = SettingsRepository.DEFAULT_THEME,
    val appLanguage: String = SettingsRepository.DEFAULT_LANGUAGE
)

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val settingsRepository: SettingsRepository
) : ViewModel() {

    val notificationsEnabled: StateFlow<Boolean> = settingsRepository.notificationsEnabledFlow
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), true)

    val soundsEnabled: StateFlow<Boolean> = settingsRepository.soundsEnabledFlow
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), true)

    val appTheme: StateFlow<String> = settingsRepository.appThemeFlow
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), SettingsRepository.DEFAULT_THEME)

    val appLanguage: StateFlow<String> = settingsRepository.appLanguageFlow
        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(5000), SettingsRepository.DEFAULT_LANGUAGE)

    fun onNotificationsEnabledChanged(enabled: Boolean) {
        viewModelScope.launch {
            settingsRepository.setNotificationsEnabled(enabled)
        }
    }

    fun onSoundsEnabledChanged(enabled: Boolean) {
        viewModelScope.launch {
            settingsRepository.setSoundsEnabled(enabled)
        }
    }

    fun onAppThemeChanged(theme: String) {
        viewModelScope.launch {
            settingsRepository.setAppTheme(theme)
        }
    }

    fun onAppLanguageChanged(language: String) {
        viewModelScope.launch {
            settingsRepository.setAppLanguage(language)
        }
    }
}

================
File: ui/navigation/AppDestinations.kt
================
package com.example.lab1.ui.navigation

object AppDestinations {
    const val LOGIN_ROUTE = "login"
    const val REGISTRATION_ROUTE = "registration"
    const val ORDER_LIST_ROUTE = "order_list"
    const val ARG_ITEM_ID = "orderItemId"
    const val ARG_MENU_ITEM_ID = "menuItemId"
    const val ARG_ACTIVE_ORDER_ID = "activeOrderId"
    const val ADD_ITEM_DETAILS_ROUTE = "add_item_details"
    const val PROFILE_ROUTE = "profile"
    const val MAIN_APP_ROUTE = "main_app"
    const val SETTINGS_ROUTE = "settings"
    const val MENU_SCREEN_ROUTE = "menu_screen"
    const val MENU_SCREEN_WITH_ORDER_ROUTE = "$MENU_SCREEN_ROUTE/{$ARG_ACTIVE_ORDER_ID}"
    const val EDIT_ORDER_ITEM_DETAILS_ROUTE = "$ADD_ITEM_DETAILS_ROUTE/edit/{$ARG_ITEM_ID}"
    const val NEW_ORDER_ITEM_DETAILS_ROUTE =
        "$ADD_ITEM_DETAILS_ROUTE/new/{$ARG_MENU_ITEM_ID}/for_order/{$ARG_ACTIVE_ORDER_ID}"
}

================
File: ui/navigation/BottomNavItem.kt
================
package com.example.lab1.ui.navigation

import androidx.annotation.StringRes
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ListAlt
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Settings
import androidx.compose.ui.graphics.vector.ImageVector
import com.example.lab1.R

sealed class BottomNavItem(
    val route: String,
    @StringRes val titleResId: Int,
    val icon: ImageVector
) {
    data object Orders : BottomNavItem(
        route = AppDestinations.ORDER_LIST_ROUTE,
        titleResId = R.string.orders_title,
        icon = Icons.AutoMirrored.Filled.ListAlt
    )

    data object Profile : BottomNavItem(
        route = AppDestinations.PROFILE_ROUTE,
        titleResId = R.string.profile_title,
        icon = Icons.Default.Person
    )

    data object Settings : BottomNavItem(
        route = AppDestinations.SETTINGS_ROUTE,
        titleResId = R.string.settings_title,
        icon = Icons.Default.Settings
    )
}

val bottomNavItems = listOf(
    BottomNavItem.Orders,
    BottomNavItem.Profile,
    BottomNavItem.Settings,
)

================
File: ui/theme/Color.kt
================
package com.example.lab1.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

================
File: ui/theme/Theme.kt
================
package com.example.lab1.ui.theme

import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.platform.LocalContext

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40
)

@Composable
fun Lab1Theme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }

        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

================
File: ui/theme/Type.kt
================
package com.example.lab1.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)

================
File: util/DataResult.kt
================
package com.example.lab1.util

sealed class DataResult<out T> {
    data class Success<T>(val data: T) : DataResult<T>()
    data class Error(val message: String) : DataResult<Nothing>()
    data object Loading : DataResult<Nothing>() 
}

================
File: util/ResourceUtils.kt
================
package com.example.lab1.util

import android.content.Context
import android.util.Log
import com.example.lab1.R
import java.util.Locale

fun getStringResourceForKey(context: Context, key: String): String {
    val desiredLocale = Locale.getDefault()
    var localizedContext = context
    val currentConfiguration = context.resources.configuration

    // Check if the context's primary locale matches the desired default locale
    val primaryLocaleInContext = if (currentConfiguration.locales.isEmpty) null else currentConfiguration.locales[0]

    if (primaryLocaleInContext != desiredLocale) {
        Log.d("ResourceUtils", "Context locale (${primaryLocaleInContext}) doesn\'t match default (${desiredLocale}). Creating new localized context for key: $key")
        val config = android.content.res.Configuration(currentConfiguration)
        config.setLocale(desiredLocale)
        localizedContext = context.createConfigurationContext(config)
    }

    val resId = when (key) {
        "pizza1_name" -> R.string.pizza1_name
        "pizza1_desc" -> R.string.pizza1_desc
        "pizza2_name" -> R.string.pizza2_name
        "pizza2_desc" -> R.string.pizza2_desc
        "pizza3_name" -> R.string.pizza3_name
        "pizza3_desc" -> R.string.pizza3_desc
        "salad1_name" -> R.string.salad1_name
        "salad1_desc" -> R.string.salad1_desc
        "salad2_name" -> R.string.salad2_name
        "salad2_desc" -> R.string.salad2_desc
        "drink1_name" -> R.string.drink1_name
        "drink1_desc" -> R.string.drink1_desc
        "drink2_name" -> R.string.drink2_name
        "drink2_desc" -> R.string.drink2_desc
        "dessert1_name" -> R.string.dessert1_name
        "dessert1_desc" -> R.string.dessert1_desc
        else -> 0
    }

    return if (resId != 0) {
        try {
            localizedContext.getString(resId)
        } catch (e: Exception) {
            Log.e("ResourceUtils", "Error getting string resource for ID: $resId from key: $key (locale: ${desiredLocale.toLanguageTag()})", e)
            key
        }
    } else {
        Log.w("ResourceUtils", "Unknown string resource key: $key. Returning key as fallback.")
        key
    }
}

================
File: WaiterApplication.kt
================
package com.example.lab1 

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class WaiterApplication : Application()
